\chapter{Évaluation}
% NOTE: distingué version .oN et version du code.
La gestion des modules permet plusieurs versions d'un
module d'être installé. Au sein d'un application, il
est possible de chargé plus d'une version d'un module
dans le système.

\section{Coexistence entre bibliothèque}
Les bibliothèques coexistent de deux façon principales, de façon passive dans
un système fichier et de façon active durant l'exécution d'un programme.  Un
système de fichier contient un arborescence hiérarchique de répertoires et de
fichiers avec une seule racine. Un fichier est l'entité dans un système de
fichier qui contient les données, c'est dans cette entité que le code des
bibliothèques ce situe.  Les répertoires sont les entités qui permette de
regrouper plusieurs fichiers de façon logique. La racine correspond au sommet
de la hiérarchie du système de fichier. La façon de référer au un fichier
uniquement dans un système de fichier est d'utiliser le chemin absolu. Cela
correspond à la liste des répertoires à parcourir de la racine jusqu'au
fichier. L'outil responsable d'organiser les bibliothèques sur un système
est le \textit{package manager}. Il possède plusieurs objectif incluant
l'installation de bibliothèque, la mise à jour de toute les bibliothèques
installées, la désinstallation de bibliothèque et la résolution des dépendances.

Un cas intéressant de coexistence entre bibliothèques est celui qui inclue
plusieurs versions d'une même bibliothèque, car cela peut amener des problème
à la fois sur le système de fichier et durant l'exécution d'un processus utilisant
ces bibliothèques. Il y a aussi plusieurs utilités d'avoir plusieurs version
d'une même bibliothèque, cela permet de supporter des application qui dépend de
bibliothèques antérieurs.

Un autre application est de convertir un vieux format de fichier vers un format
plus récent. Dans le cas où il n'est pas possible de plusieurs version d'une bibliothèque
il faut alors écrire un \textit{reader} pour lire le vieux format manuellement ensuite le
utilise fonctions de la version cible de bibliothèque pour générer le nouveau format du fichier.
Cette solution à comme problème que le \textit{reader} est beaucoup moins testé que la
vielle version de la bibliothèque. Cela demande aussi de réécrire qu'est-ce qui à déjà été fait.

\begin{figure}[ht]
  \includegraphics[width=30em]{figures/app_convert_v1_to_v2.pdf}
  \caption{Un exemple d'application de conversion entre deux version d'un format
  de fichier comme sqlite2 et sqlite3 exploitant la possibilité de charger plusieurs
  version d'une bibliothèque.}
\end{figure}

L'architecture de processus sur un système permet plusieurs propriétés. La
robustesse, un processus failli les autres processus ne sont pas affectés. La
sécurité et l'isolation, chaque processus possède leur mémoire qui n'est pas
accessible par les autre processus et peuvent utilisé une version spécifique
des bibliothèques. Il est possible de concevoir l'architecture de processus en
utilisant des threads.  Un \textit{thread} décrit un courant d'exécution d'un
programme. Un processus à au minimum un \textit{thread} qui correspond au
courant d'exécution principal du programme. Les \textit{threads} sont utiles
pour paralléliser l'exécution d'un processus. La création de \textit{threads}
est beaucoup plus rapide que la création d'un processus, car elle ne nécessite
pas l'appel au système d'exploitation.

Ce modèle exploite la légèreté des \textit{threads} par rapport au processus et
la possibilité de charger plusieurs version des bibliothèques qu'il a besoin au sein
du système. Cela est similaire au modèle de processus utilisé par les
système d'exploitation, sauf que l'ensemble est juste au sein d'un seul processus.
Étant donnée que les \textit{threads} vivent tous au sein d'un même processus,
il est donc facile de partagé des informations d'un \textit{thread} à un autre.
Ce qui est plus difficile avec le modèle de processus, cela nécessite l'utilisation
mécanisme comme la mémoire partagé.

%\todo{picture: Thread as Light process}

% TODO: exemple de chemin.

%et s'il c'est un cas qui peut
%contenir un coexistence néfaste.  Cela n'est possible que s'il est possible de
%distinguer les deux version de la bibliothèque et aussi répartir les appels à
%des fonctions de même nom à la bonne version de la bibliothèque.

\section{Conditions nécessaires}% FIXME: Pas un bon nom
Des conditions suffisantes pour que deux bibliothèques puissent coexister ensemble
dans un même processus incluant deux version de la même bibliothèque, c'est la pureté fonctionnelle des
fonctions et l'unicité des nom des fonctionnalité. La pureté fonctionnelle garantie
que chaque fonction de la bibliothèque retourne toujours le même résultat quand il
est invoqué avec les mêmes arguments sans utilisé l'affectation d'une variable globale.
Dans un contexte \textit{multi-threadé}, l'avantage principale est qu'il n'est pas possible
d'avoir une condition de course sur une donnée partagé si les fonctions sont purement fonctionnelle,
car pour qu'une condition de course se produise il faudrait un effet de bord (assignation), qui impliquerait
que la fonction n'est pas pure. Le fait que chaque fonctionnalité est associé à un nom unique cela inhibe
la capacité d'une bibliothèque de masquer une fonctionnalité d'une autre bibliothèque.

Une condition de courses
survient lorsque l'ordre des opérations d'un programme s'exécute dans un ordre
que le programmeur n'a pas conçu. Par exemple, un application avec deux fils
d'exécutions, un qui lit la valeur d'une variable globales l'autre qui l'écrit.
Deux scénarios sont possible, la lecture peut s'effectuer avant ou après la la
modification de la variable globale selon l'ordonnancement de ces deux fils d'exécution.
Le résultat de la lecture est dépendant de l'ordonnancement de ces deux opérations.

Comme mentionné ces conditions sont suffisante pour que deux bibliothèques coexiste sans problème,
mais elles ne sont non nécessaires. Il existe des bibliothèques
qui ne respect pas ces conditions, mais peuvent coexister avec d'autres
bibliothèques. Pour tester la coexistence entre plusieurs bibliothèques,
des expériences ont été effectué dans plusieurs systèmes de modules
existant. Le but de l'expérience est d'observer le bon fonctionnement
des la bibliothèques au sein de même processus.

Les expériences qui suivent permette d'observer
les caractéristiques des bibliothèques qui ne respecte pas ces conditions
qui peuvent cohabiter au sein d'une même application et aussi les
caractéristiques de ceux qui ne fonctionne pas.

% XXX
La capacité d'un langage d'interfacer avec d'autre langage via la FFI propage
les limitations du langage cible.


\subsection{Librairie C}
Les bibliothèques C sont directement compilé vers un format natif pour la plateforme courante
(e.g. Window, MacOSX, Linux). Leur format diffère d'un système d'exploitation à un autre, Window utilise le format \textit{dll}
(\textit{dynamic loading library}), MacOSX utilise le format \textit{dylib} (\textit{Mach-O dynamic library})
et Linux utilise le format \textit{so} (\textit{shared library}).

Les bibliothèques C consistent de symboles qui correspondent aux fonctions est variables
globales exportées. Une bibliothèque est généralement lié à un programme C en le spécifiant
durant la création du programme. Lors de l'exécutions les symboles non définit dans le programme
sont résolu par le \textit{dynamic linker}.

% TODO: complete
% - Bibliotheques avec collisions de nom de symboles
% - Masquage de fonctionnalité d'une des deux bibliothèque
Les collisions de symboles entre deux bibliothèques cause un masquage de
fonctionnalité d'une des deux bibliothèques. Un problème est de savoir si cela est
possible de chargé deux bibliothèque avec des collisions de symboles et accéder aux
fonctionnalités distincts de ces bibliothèques.

Pour chargé deux versions d'une même bibliothèque en C, il faut utilisé un moyen
qui prend en compte des symboles communs. La résolution des symboles ce fait
par un parcourt en largeur dans la liste des symboles des bibliothèques.
Le résultat est le premier objet qui correspond au nom de symbole recherché.
L'ordre des bibliothèques utilisé dans la résolution des symboles correspond
à l'ordre spécifié lors de la construction de l'exécutable.
%    \vspace{-10pt}
\begin{center}
\begin{figure}[ht]
\begin{lstlisting}[frame=single]
> gcc -lSDL -lSDL2 exemple.c -o exemple
> ldd ./exemple
libSDL.so => /usr/lib/libSDL.so
libSDL2.so => /usr/lib/libSDL2.so
\end{lstlisting}
\caption{Création d'un exécutable lié aux deux bibliothèques
SDL et SDL2 dans cette ordre.}
\label{fig:sdl_mask_sdl2}
\end{figure}
\end{center}
Les tests ont été effectué sur deux versions de SDL, la 1.2 et la 2, car SDL utilise
peut utilisé des ressource commune comme les évènements du clavier, la mémoire et
le GPU en utilisant OpenGL pour faire de l'affichage 2D ou 3D.
Plusieurs situations sont testés, chacune sans thread et avec des threads:
\begin{enumerate}
    \item Une utilisation de SDL minimaliste qui n'écoute pas les évènements utilisateurs.
    \item Une utilisation de SDL avec une boucle d'évènements de base.
    \item Une utilisation de SDL avec une utilisation d'un contexte OpenGL.
\end{enumerate}

%% SDL1.2 appel ces propres fonctions et SDL2 appel ces propres fonctions.
Puisque SDL1.2 et SDL2 on des collisions de symboles (i.e.\ \verb+SDL_Init+, \verb+SDL_FillRect+, \verb+SDL_BlitSurface+,
\dots), l'une des premiers observations à effectuer est la bonne répartition des appels de fonctions des deux bibliothèques
dans le contexte d'une même application. Le problème à identifier est un appels à une fonction qui est dans SDL1.2 qui est redirigé
vers SDL2. Le facteur qui influence laquelle des deux bibliothèques va masquer l'autre est l'ordre dans laquelle
ils sont lié au programme à la création, comme montré à la figure-\ref{fig:sdl_mask_sdl2}.

Le masquage amène une problématique qui peut mener à une défaillance du programme, car cela peut provoquer
la transmission d'une structure incompatible de la première bibliothèque à la deuxième. Dans le cas de SDL, la structure
\verb+SDL_Surface+ à une disposition différente des champs, donc incompatible.
Le premier champ qui décale l'alignement de ces deux structures est le \textit{pitch},
qui dans SDL1.2 est déclaré en Uint16 alors qu'en SDL2 il est un int qui sont des types de
taille différente. Donc, l'accès au prochain champ \texttt{pixels} est différent entre SDL1.2
et SDL2, ce qui peut causer un accès non désiré en mémoire si une structure de SDL1.2 est accédé comme
une structure de SDL2.
\begin{center}
\begin{tabular}{p{18em}p{18em}}
\begin{lstlisting}[frame=single,numbers=left]
typedef struct SDL_Surface {
    Uint32 flags;
    SDL_PixelFormat *format;
    int w, h;
    Uint16 pitch;
    // Different offset here
    void *pixels;
    ...
} SDL_Surface;
\end{lstlisting}&
\begin{lstlisting}[frame=single,numbers=right]
typedef struct SDL_Surface {
    Uint32 flags;
    SDL_PixelFormat *format;
    int w, h;
    int pitch;
    // Different offset here
    void *pixels;
    ...
} SDL_Surface;
\end{lstlisting}\\
\end{tabular}
\end{center}
%% Instable: gcc -lSDL -lSDL2 ...
Puisque les programmeurs cherchent une certaine stabilité dans leurs bibliothèques, ils ont
tendance à éviter les dépendances avec des bibliothèques qui ont des collisions de fonctionnalités.
Il est peut probable d'avoir une cohabitation entre deux bibliothèques avec des nom de fonctionnalités
similaires lié à un programme où bibliothèque par des arguments du compilateur.

Le cas qui pourrait permettre plusieurs bibliothèques avec des collisions de symboles
au sein d'une même est avec l'API du \textit{dynamic linker}. Un teste simple permet
de démontrer la capacité de répartir les appels d'une fonction identifié par le même nom
dans différentes bibliothèques.

La structure générale des tests est organisé comme suit. Deux bibliothèques implémentant
une interaction valide avec l'une des versions de la bibliothèque (e.g. SDL1.2, SDL2).
Un application qui unie ces deux bibliothèques en utilisant l'API du
\textit{dynamic linker} pour exécuter ces deux bibliothèques séquentiellement ou
parallèlement.

%% TODO: expliquer la structure des programmes.

Dans le test minimaliste sans gestion d'évènements l'exécution des bibliothèque
fonctionne dans les deux cas, séquentiellement et en parallèle. La raison qui
explique ce bon fonctionnement est la répartition des appels au fonctions
des deux bibliothèques et le fait qu'il n'utilise pas de structure commune,
qui pourrait causer des conditions de course dans le test en parallèle.

\begin{center}
  \begin{figure}[ht]
\begin{lstlisting}[language=C,frame=single]
#include <SDL/SDL.h>

int main(int argc, char **argv) {
  SDL_Init(SDL_INIT_VIDEO);
  SDL_WM_SetCaption("sdl1_2", NULL);
  SDL_Surface *win =
    SDL_SetVideoMode(200, 200, 24, SDL_HWSURFACE);

  Uint32 color = SDL_MapRGB(win->format, 255, 0, 0);

  SDL_FillRect(win, NULL, color);
  SDL_Flip(win);
  SDL_Delay(1000);

  SDL_FreeSurface(win);
  SDL_Quit();
  return 0;
}
\end{lstlisting}
    \caption{Programme qui utilise la bibliothèque SDL1.2 sans la gestion des évènements
    Cette application génère une fenêtre rouge qui se ferme après 1 seconde de délais.}
  \end{figure}
\end{center}

%TODO: wrap these into frame
\begin{center}
  \begin{figure}[ht]
\begin{lstlisting}[language=C,frame=single]
#include <SDL2/SDL.h>

int main(int argc, char **argv) {
  SDL_Init(SDL_INIT_VIDEO);
  SDL_Window *win = SDL_CreateWindow("title",
      SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
      200, 200, SDL_WINDOW_SHOWN);
  SDL_Surface *screen = SDL_GetWindowSurface(win);

  Uint32 color = SDL_MapRGB(screen->format, 0, 255, 0);
  SDL_FillRect(screen, NULL, color);
  SDL_UpdateWindowSurface(win);
  SDL_Delay(1000);
  SDL_DestroyWindow(win);
  SDL_Quit();
  return 0;
}
\end{lstlisting}
    \caption{Programme qui utilise la bibliothèque SDL2 sans la gestion des évènements.
    Cette application génère fenêtre verte qui se ferme aussi après 1 seconde de délais.}
  \end{figure}
\end{center}

Dans le test incluant des évènements, l'hypothèse supposait que les évènements du clavier
aurait causé des problèmes de conditions de course en parallèle. Le test a aussi fonctionné
séquentiellement et en parallèle, malgré la dépendance commune du clavier.

Le test qui incluait OpenGL, n'aurait pas dû fonctionné par hypothèse. Les deux version
de SDL référait à une unique version de OpenGL. Le résultat a été surprenant, car le test
séquentielle et parallèle à fonctionné. Ce qui amène à conclure qu'il existe des cas
de coexistence entre des bibliothèques avec des collisions de symbole qui fonctionne
sans causer des problèmes d'exécution.



%%% Possible de compile le programme principale en un exécutable et en bibliothèque.
%Les deux programmes sont compilés en bibliothèques et en exécutables.
%Le fonctionnement de chaque programme est testé de façon séparé.
%Le programme principale, qui charge le main des deux autres programmes en utilisant
%l'API du \textit{dynamic loader}, est compilé en mode séquentiel et en mode parallèle.
%La version séquentielle permet d'observer la coexistance entre les deux bibliothèques,
%celle parallèle est utilisé pour évaluer les conditions de course sur des ressources
%communes.
%
%%% TODO: schema.
%\begin{center}
%  \begin{figure}[ht]
%\begin{lstlisting}[language=C,frame=single]
%  ...
%  void *hndl1 = dlopen(prog1, RTLD_NOW);
%  void *hndl2 = dlopen(prog2, RTLD_NOW);
%
%  int(*main1)(int,char**) = dlsym(hndl1, "main");
%  int(*main2)(int,char**) = dlsym(hndl2, "main");
%
%  main1(argc, argv);
%  main2(argc, argv);
%  ...
%\end{lstlisting}
%  \caption{Le chargement et exécution séquentiel de la fonction main des programmes
%  \textbf{prog1} et \textbf{prog2} via l'API du \textit{dynamic loader}.}
%  \end{figure}
%\end{center}
%% \begin{center}
%%   \begin{figure}[ht]
%% \begin{lstlisting}[language=C,frame=single]
%% struct MainCallback {
%%   int argc;
%%   char **argv;
%%   int (*main)(int,char**);
%% };
%%
%% void *run(void* args) {
%%   struct MainCallback* callback = (MainCallback*)args;
%%   callback->main(callback->argc, callback->argv);
%%   return NULL;
%% }
%% \end{lstlisting}
%%   \caption{Callback utilisé pour exécuté le main de la bibliothèque chargé par
%%   \textbf{dlsym} en parallèle avec pthread.}
%%   \end{figure}
%% \end{center}
%
%\begin{center}
%  \begin{figure}[ht]
%\begin{lstlisting}[language=C,frame=single]
%  ...
%  struct MainCallback callback = {
%    .argc = argc,
%    .argv = argv,
%    .main = main1
%  };
%
%  pthread_t th1;
%  pthread_create(&th1, NULL, run, &callback);
%  main2(argc, argv);
%  pthread_join(th1, NULL);
%  ...
%\end{lstlisting}
%    \caption{Exécution du code des deux programme en parallèle avec l'utilisation de pthread.
%    Contrairement à la figure précédente, la fonction main de \textbf{prog1} exécuté dans un
%    threads.}
%  \end{figure}
%\end{center}
%
%
%Tout d'abord, la compatibilité entre SDL1.2 et SDL2 à été testé par un code sans
%la gestion des évènements, pour vérifier si les fonctions respective de chaque
%bibliothèque étaient à appellé correctement.
%% coexistance sans interraction directe.
%#ifdef THREADED

% SDL1.2/SDL2/OpenGL
% - Hypothèse
%   - Non-threaded without OpenGL
%   - Non-threaded with OpenGL
%   - Threaded without OpenGL
%   - Threaded with OpenGL
% - Démarche
% - Résultat
% - Petite Conclusion

% OpenSSL+RSA/OpenSSL+Socket
% - Hypothèse
% - Démarche
% - Résultat
% - Petite Conclusion

\clearpage
\subsection{Bibliothèque Scheme}
La compatibilité entre version a été testé sur la partie cryptographique
RSA de OpenSSL, SDL et un générateur aléatoire qui possède un état global.
Pour observer le comportement de bibliothèque Scheme liant des fonctionnalités
implémenté dans un autre langage, dans ces exemple C. Ces tests montrent le problème
de masquage décrit précédemment dans des bibliothèques réelle.
Pour tester les bibliothèques natives en Scheme, il a fallut écrire des
un code spécial pour lier les types et les fonction au monde Scheme. Ces

Par hypothèse la partie cryptographique des deux versions de OpenSSL peuvent
coexister. Chacune des fonctions cryptographique de OpenSSL1.0 et OpenSSL1.1
exécute du code disjoint qui n'interfère pas avec une zone mémoire commune.
Cela implique qu'un appelle à une fonction de OpenSSL1.0 n'affectera pas les
résultats des appelles futures de OpenSSL1.1. Les fonctions nécessaires
pour tester la partie cryptographique RSA sont:
\begin{itemize}
    \item \lstinline{PEM_read_bio_RSA_PUBKEY} et \lstinline{PEM_read_bio_RSAPrivateKey}:
        Ce sont les fonctions OpenSSL qui permettent de lire la clef publique et la clef privée.
    \item \lstinline{RSA_public_encrypt}:
        La fonction d'encryption qui crypte un  message en utilisant une clef publique.
    \item \lstinline{RSA_private_decrypt}:
        La fonction qui permet de décrypter un message en utilisant la clef privée.
    \item \lstinline{RSA_free}:
        La fonction qui libère la mémoire alloué pour les clefs publiques et privées.
        Cette fonction n'est pas nécessaire pour les testes, mais utile pour une bonne
        gestion mémoire.
\end{itemize}
La structure de donnée utilisé par les fonctions d'OpenSSL pour la cryptographie RSA
est un pointeur vers un enregistrement RSA. La liaison avec le type C est effectué avec
la forme spécial \lstinline{c-define-type}.

Le teste consiste à crypter un message en utilisant une clé publique, décrypter le
cryptogramme avec la clé privée et comparer le message original avec le message décrypter
pour les deux versions de OpenSSL chargé dans le même processus. Pour vérifier la bonne
invocation des fonctions de OpenSSL1.0 et OpenSSL1.1 respectif le débogueur \textbf{gdb}
a été utilisé. Les bibliothèques d'OpenSSL consiste en deux fichier \url{libssl.so} et \url{libcrypto.so}.
En déboguant la répartition des appels avec \textit{gdb}, il y a eu l'observation que
la bibliothèque \url{libcrypto.so} de OpenSSL1.1 masquait la version de OpenSSL1.0 s'il
n'est pas spécifié explicitement lors de la création de la bibliothèque Scheme \textit{rsa.scm}
comme à la figure-\ref{fig:scm_masq1}. Les raisons sont liées à plusieurs facteurs qui étaient présents
durant l'expérience. L'ordre de recherche des symboles qui inclue les symboles des bibliothèques lié à
l'exécutable qui sont prioritaire qui contenait \url{libssl.so} et \url{libcrypto.so} de OpenSSL1.1.
Dans ce cas, il était possible de résoudre ce problème en ajoutant une
dépendance directe à \textit{libcrypto} lors de la construction des bibliothèques Scheme \verb+RSA+
comme montré dans la figure-\ref{fig:scm_masq_fix1}.

\begin{center}
\begin{figure}[ht]
\begin{lstlisting}[frame=single]
gsc-script -o rsa-1-0-0.o1 \
  -cc-options '-I /usr/include/openssl-1.0' \
  -ld-options '-L /usr/lib/openssl-1.0 -lssl' \
  -prelude '(define-cond-expand-feature|openssl-v10|)' rsa.scm

gsc-script -o rsa-1-1-0.o1 \
  -ld-options "-lssl" rsa.scm
\end{lstlisting}
\caption{Création des bibliothèques \textit{rsa.scm} pour OpenSSL1.0 et OpenSSL1.1
sans la spécification de \textit{libcrypto.so}}
\label{fig:scm_masq1}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[ht]
\begin{lstlisting}[frame=single]
gsc-script -o rsa-1-0-0.o1 \
  -cc-options '-I /usr/include/openssl-1.0' \
  -ld-options '-L /usr/lib/openssl-1.0 -lssl -lcrypto' \
  -prelude '(define-cond-expand-feature|openssl-v10|)' rsa.scm

gsc-script -o rsa-1-1-0.o1 \
  -ld-options "-lssl -lcrypto" rsa.scm
\end{lstlisting}
\caption{Création des bibliothèques \textit{rsa.scm} pour OpenSSL1.0 et OpenSSL1.1
avec la spécification de \textit{libcrypto.so}}
\label{fig:scm_masq_fix1}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[ht]
\includegraphics{figures/libssl_masking.pdf}
\caption{Schéma des dépendances entre les bibliothèques au sein d'un processus.
Les dépendances qui ont été lié dynamiquement lors la création de l'application sont représenté par une flèche avec
trait plein sans annotation. Ceux qui représente les chargement de bibliothèque dynamique via \texttt{dlopen} ont
l'annotation \textit{dl}. La flèche en pointillé indique un masquage des symboles de la bibliothèque
source par celle pointée.}
\label{fig:scm_masq_schema}
\end{figure}
\end{center}

TODO: rng générator

%\begin{lstlisting}[frame=single]
%(c-define-type RSA* (pointer "RSA"))
%\end{lstlisting}


%Heureuse Gambit Scheme possède un interface pour lié
%une fonction C au monde Scheme.

%Une bibliothèque liant les fonctions principales de SDL au monde Scheme.


%\TODO{Fill}
% SDL / SDL2
% - Hypothèse
% - Démarche
% - Résultat
% - Petite Conclusion

% OpenSSL+RSA
% - Hypothèse
% - Démarche
% - Résultat
% - Petite Conclusion

% RNG-splitmx64/RNG-xoroshiro128+
% - Hypothèse
% - Démarche
% - Résultat
% - Petite Conclusion


\subsection{Bibliothèque Javascript (NodeJS)}
%\TODO{Fill}
% Démarche général
% express / sqlite3
% - Hypothèse * 2
% - Démarche/Expérimentation
% - Résultat
% - Petite Conclusion

Pour effectué des tests sur la coexistences de différente version d'une bibliothèque
Javascript dans NodeJS, il faut tout d'abord permettre l'importation de plusieurs
versions d'une même bibliothèque. Dans NodeJS, l'importation de module s'effectue
avec la fonction \verb|require(module-name)|. Puisque l'information de version
de la bibliothèque n'est pas fournit en paramètre à la fonction, il faut donc
utilisé une autre méthode de forcer plusieurs versions des bibliothèque.
La configuration d'un module dans NodeJS utilise le format JSON pour spécifier
le nom, la version, les dépendances, \dots.

Les dépendances sont conservées sous la forme d'un arbre, chaque module à ses dépendances directes
qui ont aussi des dépendances indirectes.  Lors de l'écriture d'un module Javascript, il est possible
de spécifier la version de chaque dépendence dans le fichier \textit{package.json}.
\begin{verbatim}
{
  ...
  "dependencies": {
    "express": "4.16.3"
  },
  ...
}
\end{verbatim}
En utilisant cette fonctionnalité du système de module de NodeJS, deux bibliothèques \textit{wrapper}
sont écrit pour interfacer les deux versions de express. Puisque l'API public d'express n'a pas changé entre
les versions 3.21.1 et 4.16.3, il est possible de recycler le code de la bibliothèque qui encapsule une
version d'express (figure-\ref{fig:express}).
\begin{center}
\begin{figure}[ht]
    % FIXME: language=Javascript
    \begin{lstlisting}[language=C,frame=single]
const express = require('express');

function start() {
  const app = express();
  const port = Math.floor(Math.random() * 64535 + 1000);

  app.get('/', (req, res) => {
    res.send('Hello world!\n');
  });

  app.listen(port, 'localhost', () => {
    console.log('Listen on port ' + port);
  });
}
exports.start = start;
\end{lstlisting}
\end{figure}
\label{fig:express}
\end{center}
Le programme principale ne fait qu'importer les deux encapsulation de bibliothèque
et invoque la fonction \textit{start}.

Le résultat attendu dans cette expérience est que ces deux version de la bibliothèque
express coexiste sans problème, sauf dans le cas où le port tcp utilisé par les deux
version est le même. Dans ce cas, c'est la bibliothèque dont la fonction
\textit{start} a été invoqué en premier qui va monopoliser le tcp port. Dans ce cas
la ressource qui inhibe la coexistence de ces modules au sein d'un même processus
est lié au \textit{socket}.

\subsection{Variables globales communs}

Puisque qu'il n'existe qu'une seul instance de chaque bibliothèque en mémoire, cela implique
que les variables globale d'une bibliothèque.

Définissons 3 bibliothèques B, C et D telle que D a une variable globale nommée \textit{value}.
B et C ont chacun une dépendance directe vers D, et exportent une référence de la variable
globale \textit{value} de D.

Le programme principale A commence par charger B et C. Ensuite lit la valeur de \textit{B.D.value}
puis modifie \textit{C.D.value} et relit \textit{B.D.value}. Le teste réussi si la valeur de
\textit{B.D.value} reste inchangé par la modification de \textit{C.D.value}. Cela implique que
les références vers la bibliothèque D est différente de via B et via C.

Dans NodeJS, un module peut être installé via un dossier, un archive tarball, un dépôt de code source git ou
directement via Npmjs. Puisque un module publié dans Npmjs ne peut pas être retiré facilement étant donné
la politique lié au module (\url{https://docs.npmjs.com/cli/unpublish}).
%L'expérience va utilisé un serveur git qui est auto-hébergé.
