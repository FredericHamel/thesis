\chapter{Migration de code}
\label{ch:task_migration}

Ce chapitre traite du mécanisme de diffusion de modules qui est utilisé dans
la migration de code. Notre approche exploite la sérialisation des objets
Scheme, le langage Termite et l'installation automatique des modules durant
l'exécution.

\section{Systèmes distribués}

Les systèmes distribués sont constitués d'un ensemble de nœuds interconnectés
de calculs. Les nœuds interagissent par l'envoi et la réception de message
au sein d'un réseau de communication. Chaque nœud a un but spécifique. Le
\textit{Web} est un exemple notable qui permet d'avoir un aperçu.
Il est composé de clients et de serveurs qui exécutent
des applications clients et serveurs différentes.

L'implémentation d'un système distribué inclut le développement des applications
installé sur les nœuds et la logique d'interaction entre les nœuds. Il est
possible de voir l'ensemble des programmes sur les nœuds comme un programme
global. Les problèmes discutés dans ce chapitre sont les suivants:

\begin{itemize}

  \item {\bf RPC:} Comment l'appel distant à une procédure (RPC)
    implémentée quand l'envoyeur et le receveur ne sont pas conçus
    ensemble?

  \item {\bf Mise à jour de code:} Comment la mise à jour du programme d'un
    nœud est effectuée lors d'un \textit{bugfix} ou lorsqu'une nouvelle
    version est disponible?

  \item {\bf Migration de tâche:} Comment déplacer un service sur un nouveau
    nœud quand le système sous-jacent est sur un système d'exploitation
    différent, à une architecture différente, etc.?

  \item {\bf Opération continue:} Comment éviter les interruptions dans les
    situations précédentes?

\end{itemize}

Le langage Termite Scheme~\cite{DBLP:conf/erlang/Germain06} a été conçu
pour simplifier l'implémentation de systèmes distribués et fournit
certaines solutions aux problèmes de ces systèmes. Le langage Termite Scheme est
fortement inspiré des concepts du langage de programmation d'Erlang avec la
syntaxe et la sémantique de Scheme. Une fonctionnalité intéressante qui est
absente en Erlang est la capacité d'envoyer une continuation en message.
Termite Scheme est implémenté sur le système Gambit Scheme qui offre
une façon de sérialiser la plupart des objets Scheme incluant les
procédures et les continuations.

La sérialisation de procédures est un outil utile pour implémenter
un protocole RPC. En plus des procédures, il est possible de sérialiser
des continuations. Une continuation est une structure de donnée qui capture
l'état d'un processus. Donc il est possible de transmettre l'état d'un
processus sur un autre nœud.

L'implémentation originale de Termite avait certaines limitations
lors de la sérialisation des procédures et des continuations. Dans
le cas interprété, les procédures et les continuations sont transmises
sans problème entre les nœuds. Dans le cas compilé, il faut que
chaque nœud possède le code compilé des procédures qui sont transmises.


\section{Le langage Termite}

Ce langage, conçu par Guillaume Germain en 2006, est l'implémentation du style
de programmation par message d'Erlang dans Gambit Scheme.  Les processus sont
représentés par les threads de Scheme. La communication entre ces processus est
effectuée par un système de boîte de message présent dans Gambit. Chaque thread
possède une file d'attente de messages entrants.

Termite expose plusieurs procédures pour gérer les processus et la transmission
de message entre chacun des nœuds.

\begin{itemize}
  \item La procédure \texttt{(spawn \textit{<thunk>} \#!key \textit{<name>})} permet de
    créer des processus Termite. Le paramètre \textit{<thunk>} est la procédure principale
    du thread. Le paramètre \textit{<name>} est un paramètre associatif optionnel.V

  \item La procédure \texttt{(! \textit{<node>} \textit{<msg>})} envoie le message
    \lstcode{msg} au nœud \lstcode{node}.

  \item La procédure \lstcode{(?)} permet de recevoir un message
    envoyé par un autre processus au nœud courant.

  \item La procédure \texttt{(!? \textit{<node>} \textit{<msg>})} envoie un message au
    nœud \lstcode{node} et attend la réponse.

  \item La macro \texttt{(recv (\textit{<pattern>} \textit{<expr1>} \dots) \dots)}
    permet un filtrage par motif des messages reçus du nœud courant.

\end{itemize}

L'ensemble des données transmis sont sérialisées par la procédure \lstcode{object->u8vector}.
La sérialisation d'une procédure contient le nom de celle-ci et un entier qui l'identifie.
La figure~\ref{fig:proc_serialization} montre un exemple de la sérialisation d'une procédure
compilée. Cette représentation est conçue pour être compacte et éviter la redondance dans les
données. En plus, elle est indépendante de l'architecture de la machine.
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.25]{figures/proc-serialization}
  \caption{La représentation du résultat de la sérialisation en \texttt{u8vector} de la procédure
    \texttt{sqrt}.}
  \label{fig:proc_serialization}
\end{figure}

\section{\textit{Hook} des procédures inconnues}
%
Le système Termite permet la migration de code compilé avec les procédures
\lstcode{object->u8vector} et \lstcode{u8vector->object}. Ces procédures
effectuent respectivement la sérialisation et la désérialisation.
La sérialisation d'une procédure est encodée par le nom de la procédure et
un entier qui l'identifie (\texttt{id}).

Le nom qualifié de la procédure (i.e. qui contient un \texttt{\#}) est composé
de l'espace de nom et du nom court. La procédure \lstcode{_hamt#make-hamt} est
dans l'espace de nom \lstcode{_hamt} et à un nom court \lstcode{make-hamt}.
L'espace de nom dans un module qui est hébergé correspond au \lstcode{module-ref}
qui est dans le cas des modules hébergés l'URL du dépôt contenant
le code du module.

Dans le processus de désérialisation, le nom de la procédure et le \texttt{id}
sont utilisés pour retrouver la procédure. Un \textit{hook} est invoqué
si la procédure n'existe pas dans le processus courant. Le but de
ce \textit{hook} est de dynamiquement installer et charger le module 
qui implémente la procédure inconnue.

%\newpage
\section{Exemple de migration de code}

L'exemple d'application est une horloge programmable implémentée
en Scheme avec Termite. C'est montre un exemple de migration
de tâche qui contient du code non présent sur le nœud destination.
Cette horloge offre un API simple:
\begin{itemize}
  \item La modification du fuseau horaire est faite en envoyant
    un message entier.

  \item Le message \lstcode{timezone-get} permet de récupérer
    le fuseau horaire courant.

  \item Le message \lstcode{update-code} permet la mise à jour
    dynamiquement du code du serveur.

  \item Tous les autres messages sont rejetés par le serveur.
\end{itemize}

Le code exécuté par la boucle principale est présent dans la figure
\ref{fig:termite-clock@v1}. L'affichage de l'heure est actualisé à
une fréquence constante. Le serveur démarre un nœud Termite qui
exécute la boucle de la figure \ref{fig:termite-clock@v1}.

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
;; clock-app.scm
(import (termite))
(import (github.com/frederichamel/termite-clock @v1))

;; Should be integrated in the system.
(##unknown-procedure-handler-set!
  (lambda (name id)
    (let* ((name-str (##symbol->string name))
           (proc/ns (##reverse-string-split-at name-str #\#)))
      (and (##pair? (##cdr proc/ns))
           (let ((mod-name (##last proc/ns)))
             (##load-module (##string->symbol mod-name))
             (let ((proc (##get-subprocedure-from-name-and-id name id)))
               proc))))))

(define node (make-node "0.0.0.0" 3000))
(define (start)
  (node-init node)
  (display "\033[H\033[J")
  (clock-start 'clock-app)
  (wait-for (resolve-service 'clock-app)))

(start)
\end{mplisting}
\end{center}
  \caption{Le code du serveur qui configure la \textit{hook}
    qui résout les références à procédures inconnues.
    C'est effectué avec la procédure \lstcode{\#\#unknown-procedure-handler-set!}.
    }
  \vspace*{4ex}
\end{figure}


\begin{figure}[h!]
  \centering
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
(define (clock-thread-loop timezone)
  (let tick ()
    (let* ((now (time->seconds (current-time)))
           (next (* 0.5 (floor (+ 1 (* 2 now))))) ;; next 1/2 second
           (to (seconds->time next)))
      (let wait ()
        (recv
          ((from tag timezone) (where (integer? timezone))
           (! from (list tag 'ok)) ;; send confirmation
           (clock-thread-loop timezone))

          ((from tag ('update-code k))
           (! from (list tag 'ok)) ;; send confirmation
           (k timezone))

          ((from tag 'timezone-get)
           (! from (list tag timezone))
           (wait))

          (msg
           (pp msg)
           (wait))

          (after to
           (clock-update next timezone)
           (tick)))))))
\end{mplisting}
  \caption{C'est le code de la boucle principale de l'horloge programmable.}
  \label{fig:termite-clock@v1}
\end{figure}

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
;; config.scm
(define local (make-node "a.local" 3000))
(define remote (make-node "b.local" 3000))

(node-init local)
\end{mplisting}
\end{center}
  \caption{Configuration des nœuds qui est utilisé sur les clients.}
  \vspace*{4ex}
\end{figure}

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
(import (termite))

;; Configure the current node.
(include "config.scm")

;;; Update timezone
(let* ((args (command-line))
       (rest (cdr args)))
  (if (or (null? rest)
          (pair? (cdr rest)))
      (pp (!? (remote-service 'clock-app remote) 0))
      (let ((timezone (string->number (car rest))))
        (pp (!? (remote-service 'clock-app remote) (or timezone 0))))))
\end{mplisting}
\end{center}
  \caption{Un programme qui change le fuseau horaire utilisé par
    l'horloge.}
  \vspace*{4ex}
\end{figure}

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
(import (termite))
(import (github.com/frederichamel/termite-clock @v2))

;; Configure the current node.
(include "config.scm")

(!? (remote-service 'clock-app raspi4)
    (list 'update-code clock-thread-loop))
\end{mplisting}
\end{center}
  \caption{Un exemple de mise à jour du code du serveur
    par le message \lstcode{update-code}.}
  \vspace*{4ex}
\end{figure}

\section{Conclusion}
Ce chapitre présente le mécanisme de diffusion des modules utilisés
dans la migration de code. L'exemple de l'horloge montre une application
de mise à jour dynamique du code qui est possible grâce au mécanisme
de diffusion du code. Notre implémentation de ce système permet l'installation
de la nouvelle version d'un module qui répare le bug dans l'application
\texttt{termite-clock}.

Ce mécanisme est utile pour mettre à jour un serveur évolutif
sans l'interrompre. Notre approche permet la diffusion de modules
entre les nœuds d'un système distribué.

