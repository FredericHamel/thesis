\chapter{Migration de code}
\label{ch:task_migration}

Les systèmes distribués sont constitué d'un ensemble de nœuds interconnecter
de calculs. Les nœuds interagissent par l'envoie et la réception de message
au sein d'un réseau de communication. Chaque nœud a but spécifique. Le
\textit{World Wide Web} est un exemple notable qui permet d'avoir un aperçu.
Ils est composé de clients et de serveurs qui roulent des application
clients et serveurs différent.

L'implémentation d'un système distribué inclut le développement des applications
installé sur les nœuds et la logique d'interaction entre les nœuds. Il est
possible de voir l'ensemble des programme sur les nœuds comme un programme
global. Les problèmes discutés dans ce chapitre sont les suivant:

\begin{itemize}

  \item {\bf RPC:} Comment l'appelle distant à une procédure (RPC)
    implémenté quand l'envoyeur et le receveur ne sont pas conçu
    ensemble?

  \item {\bf Mise à jour de code:} Comment la mise à jour du programme d'un
    nœud est effectué lors d'un \textit{bugfix} ou une nouvelle
    version est disponible?

  \item {\bf Migration de tâche:} Comment déplacer un service sur un nouveau
    nœud quand le système sous-jacent est sur un système d'exploitation
    différent, a un architecture différente, \dots?

  \item {\bf Opération continue:} Comment éviter les interruptions dans les
    situations précédentes?

\end{itemize}

Le langage Termite Scheme\cite{DBLP:conf/erlang/Germain06} a été conçu
pour simplifier l'implémentation de systèmes distribués et fournit
certaine solution au problèmes de ces système. Le langage Termite Scheme est
fortement inspiré des concepts du langage de programmation d'Erlang avec la
syntaxe et la sémantique de Scheme. Une fonctionnalité intéressante qui est
absent en Erlang est la capacité d'envoyer une continuation en message.
Termite Scheme est implémenté sur le système Gambit Scheme qui offre la
une façon de sérialiser la plupart des objets Scheme incluant les
procédures et les continuations.

La sérialisation de procédures est un outil utile dans pour implémenter
un protocole RPC. En plus des procédures, il est possible de sérialiser
des continuations. Une continuation est une structure de donnée qui capture
l'état d'un processus. Donc il est possible de transmettre l'état d'un
processus sur un autre nœud.

L'implémentation original de Termite avait certaines limitations
lors de la sérialisation des procédures et des continuations. Dans
le cas interprété les procédures et les continuations sont transmis
sans problème entre les nœuds. Dans le cas compilé, il faut que
chaque nœud possède la définition des procédures qui sont transmis.


\section{Le langage Termite}

Ce langage conçu par Guillaume Germain en 2006 est l'implémentation
du style de programmation par message d'Erlang dans Gambit Scheme.
Les processus sont représentés par les threads de Scheme. La communication
entre ces processus est effectué par un système de boîte de message
présent dans Gambit. Chaque thread possède une queue de message entrant.

Termite expose plusieurs procédures pour gérer les processus et la transmission
de message entre chacun des nœuds.

\begin{itemize}
  \item La procédure \texttt{(spawn \textit{<thunk>} \#!key \textit{<name>})} permet de
    créer des processus Termite.

  \item La procédure \texttt{(! \textit{<node>} \textit{<msg>})} envoie le message
    \lstcode{msg} au nœud \lstcode{node}.

  \item La procédure \lstcode{(?)} permet de recevoir un message
    envoyé par un autre processus au nœud courant.

  \item La procédure \texttt{(!? \textit{<node>} \textit{<msg>})} envoie un message au
    nœud \lstcode{node} et attend la réponse.

  \item La macro \texttt{(recv (\textit{<pattern>} \textit{<expr1>} \dots) \dots)}
    permet un \textit{pattern-matching} sur les message reçu du nœud courant.

\end{itemize}

\section{\textit{Hook} des procédures inconnues}
Le système Termite permet la migration de code compilé avec les procédures
\lstcode{object->u8vector} et \lstcode{u8vector->object}. Ces procédures
effectuent respectivement la sérialisation et la désérialisation.
La sérialisation d'une procédure est encodé par le nom de la procédure et
un id.

Le nom qualifié de la procédure (i.e. qui contient un \texttt{\#}) est composé
de l'espace de nom et du nom court. La procédure \lstcode{_hamt#make-hamt} est
dans l'espace de nom \lstcode{_hamt} et à un nom court \lstcode{make-hamt}.
L'espace de nom dans un module qui est hébergé correspond au \lstcode{module-ref}
qui correspond dans le cas des modules hébergés à l'url du dépôt content
le code du module.

Dans le processus de désérialisation le nom de la procédure et le id
est utilisé pour retrouvé la procédure. Un \textit{hook} est invoqué
si la procédure n'existe pas dans le processus courant. Le but de
ce \textit{hook} est de dynamiquement installer et charger le module 
qui implémente la procédure inconnue.

%\newpage
\section{Exemple de migration de code}

L'exemple d'application est un horloge programmable implémenté
en Scheme avec Termite. L'exemple montre un exemple de migration
de tâche qui contient du code nom présent sur le nœud destination.
Cette horloge offre un API simple:
\begin{itemize}
  \item La modification du fuseau horaire est fait en envoyant
    un entier.

  \item Le message \lstcode{timezone-get} permet de récupérer
    le fuseau horaire courant.

  \item Le message \lstcode{update-code} permet la mise à jour du
    code du serveur à l'exécution.

  \item Tous les autres messages sont rejetés par le serveur.
\end{itemize}

Le code exécuté par la boucle principale est présent dans la figure
\ref{fig:termite-clock@v1}. L'affichage de l'heure est actualisé à
une fréquence constante. Le serveur démarre un nœud Termite qui
exécute la boucle de la figure \ref{fig:termite-clock@v1}.

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
;; clock-app.scm
(import (termite))
(import (github.com/frederichamel/termite-clock @v1))

;; Should be integrated in the system.
(##unknown-procedure-handler-set!
  (lambda (name id)
    (let* ((name-str (##symbol->string name))
           (proc/ns (##reverse-string-split-at name-str #\#)))
      (and (##pair? (##cdr proc/ns))
           (let ((mod-name (##last proc/ns)))
             (##load-module (##string->symbol mod-name))
             (let ((proc (##get-subprocedure-from-name-and-id name id)))
               proc))))))

(define node (make-node "0.0.0.0" 3000))
(define (start)
  (node-init node)
  (display "\033[H\033[J")
  (clock-start 'clock-app)
  (wait-for (resolve-service 'clock-app)))

(start)
\end{mplisting}
\end{center}
  \caption{Le code du serveur qui configure la \textit{hook}
    qui résout les références à procédures inconnues.
    C'est effectué avec la procédure \lstcode{\#\#unknown-procedure-handler-set!}.
    }
  \vspace*{4ex}
\end{figure}


\begin{figure}[h!]
  \centering
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
(define (clock-thread-loop timezone)
  (let tick ()
    (let* ((now (time->seconds (current-time)))
           (next (* 0.5 (floor (+ 1 (* 2 now))))) ;; next 1/2 second
           (to (seconds->time next)))
      (let wait ()
        (recv
          ((from tag timezone) (where (integer? timezone))
           (! from (list tag 'ok)) ;; send confirmation
           (clock-thread-loop timezone))

          ((from tag ('update-code k))
           (! from (list tag 'ok)) ;; send confirmation
           (k timezone))

          ((from tag 'timezone-get)
           (! from (list tag timezone))
           (wait))

          (msg
           (pp msg)
           (wait))

          (after to
           (clock-update next timezone)
           (tick)))))))
\end{mplisting}
  \caption{C'est le code de la boucle principal de l'horloge programmable.}
  \label{fig:termite-clock@v1}
\end{figure}

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
;; config.scm
(define local (make-node "a.local" 3000))
(define remote (make-node "b.local" 3000))

(node-init local)
\end{mplisting}
\end{center}
  \caption{Configuration des nœuds qui est utilisé sur les clients.}
  \vspace*{4ex}
\end{figure}

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
(import (termite))

;; Configure the current node.
(include "config.scm")

;;; Update timezone
(let* ((args (command-line))
       (rest (cdr args)))
  (if (or (null? rest)
          (pair? (cdr rest)))
      (pp (!? (remote-service 'clock-app remote) 0))
      (let ((timezone (string->number (car rest))))
        (pp (!? (remote-service 'clock-app remote) (or timezone 0))))))
\end{mplisting}
\end{center}
  \caption{Un programme qui change le fuseau horaire utilise par
    l'horloge.}
  \vspace*{4ex}
\end{figure}

\begin{figure}[h!]
\begin{center}
  \lstset{language={Scheme},frame=single}
\begin{mplisting}{1}
(import (termite))
(import (github.com/frederichamel/termite-clock @v2))

;; Configure the current node.
(include "config.scm")

(!? (remote-service 'clock-app raspi4)
    (list 'update-code clock-thread-loop))
\end{mplisting}
\end{center}
  \caption{Un exemple de mise à jour du code du serveur en
    par le message \lstcode{update-code}.}
  \vspace*{4ex}
\end{figure}


