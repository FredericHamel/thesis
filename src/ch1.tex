
\chapter[]{Histoire}% TODO: maybe rename.
%%% - Programme/Processus
%%% - Exécutable

Les programmes modernes ont une structure \textit{modulaire},
c'est-à-dire que leur code se décompose logiquement en différentes
parties relativement indépendantes, les \textit{modules}.  Cette
structure a de nombreux avantages, entre autres sur le plan du
développement et de la maintenance.  La structure d'un programme en
vue de son \textit{déploiement}, c'est-à-dire comment son code
exécutable est stocké sur disque, chargé en mémoire, etc peut prendre
plusieurs formes.

Un programme sous forme \textit{monolithique} contient dans son code
exécutable toutes les instructions exécutées par l'ordinateur.  Cette
forme était la norme dans les premiers systèmes informatiques, et
l'est toujours pour les systèmes embarqués qui n'ont pas de système
d'exploitation indépendant.  Lorsqu'un système d'exploitation est
disponible sur l'ordinateur on peut le considérer comme étant un
module puisqu'il offre des services précis avec une interface
standardisée.  Dans ce cas, un programme peut prendre la forme d'un
seul fichier de code qui, à son exécution, communiquera avec le
système d'exploitation pour accéder à ses services.  Ce genre de
fichier exécutable est obtenu par une \textit{édition de lien
  statique} qui combine en un seul fichier tous les modules (à
l'exception du système d'exploitation).  Par rapport à la forme
monolithique, cette organisation simplifie le développement car le
programmeur n'a pas à se soucier du développement des services de base
comme l'accès aux fichiers, la gestion des processus et de la mémoire,
etc.  Le programme peut être distribué à d'autres ordinateurs ayant le
même système d'exploitation simplement en y transférant le fichier
exécutable.

==> motiver (quels problèmes ça cause le link statique) et expliquer le chargement dynamique, etc


--------------------------------------------------------


Dans les systèmes comme DOS, les programmes ou modules devaient contenir toutes les
informations nécessaire pour s'exécuter. De tels programmes sont dit lié
statiquement dans le sens qu'il ne dépende que de l'architecture sur laquelle il
a été construit. La construction des modules requière deux étapes. La compilation
de fichier source en fichier objet contenant le nom et le code des fonction.
L'édition des liens qui réunit un plusieurs fichiers objets en un module exécutable.
Dans le cas d'un seul fichier l'édition des liens ne fait que transformer le fichier
objet en fichier exécutable.

\begin{figure}[ht]
  \includegraphics[width=0.20\linewidth]{figures/basic_module_compilation.pdf}
  \caption{Construction du module A à partir des sources.}
\end{figure}

%La création d'exécutable inclut deux étapes importantes, la compilation et
%l'édition des liens. La première étape consiste à prendre un fichier de code
%source et de le traduire en fichier objet, que l'on retrouve souvent avec
%l'extension \verb|.o| ou \verb|.obj|, qui contient la représentation des
%procédures compréhensible par le processeur. Ces fichiers objets ne sont pas
%encore exécutable pour autant, il faut tout d'abord effectuer la seconde étape,
%qui va les regrouper en un exécutable. Le programme qui s'occupe de l'édition
%des liens est le \textit{linker}, la version GNU se nomme \verb|ld|.  Voici
%l'exemple de la création d'un exécutable composé des fichiers sources C
%\verb|main.c| et \verb|foo.c|:
%
%\begin{figure}[ht]
%    \begin{minipage}[t]{0.5\textwidth}
%\begin{verbatim}
%# Compilation
%gcc -c main.c -o main.o
%gcc -c foo.c -o foo.o
%# Édition de liens
%ld -o main.exe main.o foo.o
%\end{verbatim}
%    \end{minipage}
%
%    \caption{Exemple de création d'un exécutable}
%\end{figure}

Pour permettre la réutilisation de code et faciliter
l'écriture de programme plus complexe, le concept de bibliothèque de code est
apparu. Par la contrainte des systèmes, le premier type de bibliothèques utilisé
étaient dit statique.  Elles consistaient en un regroupement logique de
plusieurs fichiers objets en un archive (.a). La création d'une bibliothèque
statique peut s'effectuer avec l'utilitaire \verb|ar|. Lorsque que programme se
lie à une bibliothèque statique, il inclut tout simplement l'ensemble des
procédures contenu dans les fichiers objets. L'avantage des bibliothèques
statiques est de regrouper plusieurs fonctionnalité commune en un seul concept,
par exemple la bibliothèque mathématique \verb|libm.a| qui contient les
fonctions mathématique (i.e. \verb|cos|, \verb|sin|).  En plus,  fait que le
processus d'édition des liens, qui consiste à associer les noms des
fonctionnalités avec leur valeur (AMBIGU), n'est effectué juste une fois. Une
liaison avec une bibliothèque statique \verb|libfoo.a| qui contient le fichier
objet \verb|foo.o| est équivalent à une liaison directe avec le fichier
\verb|foo.o|.

\begin{figure}[ht]
    \begin{minipage}[t]{0.5\textwidth}
\begin{verbatim}
# Création de la bibliothèque statique libfoo.a
ar rcs libfoo.a foo.o
# Création de l'exécutable main.exe
ld -o main.exe main.o libfoo.a
\end{verbatim}
    \end{minipage}

    \caption{Exemple de création de bibliothèque statique suivit d'un exemple
    d'utilisation.}
\end{figure}

\todo{Citation}
Un des problèmes des bibliothèques statiques le coût est lié à la maintenance.  Les
programmes qui utilise des bibliothèques statiques ne permettent pas une
construction modulaire. La mise à niveau d'une des bibliothèques statiques
nécessite la recompilation du programme au complet. En plus, cela n'est pas
adapté pour des application d'un application évolutif qui peuvent être étendu
par l'utilisateur. Une solution qui a été adopté est le
concept des bibliothèques partagés (ou dynamique). Cela offre une plus grande
liberté dans la conception des programmes. Un programme qui ce lié avec une
bibliothèque partagé ne contient pas les définitions importé de la
bibliothèque, seulement l'information pour la trouvé. Cette information
consiste généralement aux noms de la fonctionnalités utilisé et des
bibliothèques dépendantes. Contrairement aux bibliothèques statiques,
l'édition des liens s'effectue à chaque exécution du programme.
Les bibliothèques partagés offre plusieurs avantages par rapport
aux bibliothèques statique.

La construction d'un programme peut s'effectuer de façon modulaire; chaque
composantes du programme peuvent être construites en séparément.  La
modification d'une des bibliothèques partagés utilisés par
le programme ne nécessite pas la recompilation de celui-ci. Le nom qui est
donné à l'entité qui résout les noms des fonctionnalités est l'éditeur de liens (\textit{dynamic linker}).
Habituellement les bibliothèques exportent des fonctions, mais il peuvent aussi
exporter plusieurs types de données comme des entiers, des nombres à virgules,
des chaînes de caractères et des données composites (structures). Chacune de ces données est
associées à un nom unique (symbole) au sein de la bibliothèque.
Il n'est pas possible d'avoir deux bibliothèques statiques qui exportent une
fonctionnalité avec le même nom au sein d'une même application, alors qu'avec
les bibliothèques partagés c'est possible. Cela limite le choix des
bibliothèques qui peuvent être utilisé simultanément au sein du programme;
chaque bibliothèque doit avoir un ensemble de nom de fonctionnalité distinct
des autres. Puisque la résolution d'une fonctionnalité retourne la première
occurrence trouvée, il n'y a rien qui empêche d'avoir plus d'une fonctionnalité
associée au même nom.

Gambit permet de l'utilisation de bibliothèques statiques et dynamiques.
Chaque fichier Scheme peuvent être compilé et lié module exécutable ou
en bibliothèque dynamique.

\begin{center}
\begin{figure}[ht]
  \begin{tabular}{l}
    \begin{mplisting}{0.5}
;; fib.scm
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))
\end{mplisting}
  \end{tabular}
  \caption{Un module qui implémente la fonction mathématique \texttt{fib}.}
  \label{fig:basic_fib_module}
\end{figure}
\end{center}

\vspace{-20pt}
La construction d'un bibliothèque dynamique à partir du fichier \texttt{fib.scm}
de la figure \ref{fig:basic_fib_module} s'effectue par le compilateur de Gambit
qui nomme \texttt{gsc}. Cela produit un fichier avec l'extension \texttt{.oN}
où le \texttt{N} correspond à la version généré de la bibliothèque qui commence à 1.

% NOTE: distingué version .oN et version du code.

\section{Coexistence entre bibliothèque}
Les bibliothèques coexistent de deux façon principales, de façon passive dans
un système fichier et de façon active durant l'exécution d'un programme.  Un
système de fichier contient un arborescence hiérarchique de répertoires et de
fichiers avec une seule racine. Un fichier est l'entité dans un système de
fichier qui contient les données, c'est dans cette entité que le code des
bibliothèques ce situe.  Les répertoires sont les entités qui permette de
regrouper plusieurs fichiers de façon logique. La racine correspond au sommet
de la hiérarchie du système de fichier. La façon de référer au un fichier
uniquement dans un système de fichier est d'utiliser le chemin absolu. Cela
correspond à la liste des répertoires à parcourir de la racine jusqu'au
fichier. L'outil responsable d'organiser les bibliothèques sur un système
est le \textit{package manager}. Il possède plusieurs objectif incluant
l'installation de bibliothèque, la mise à jour de toute les bibliothèques
installées, la désinstallation de bibliothèque et la résolution des dépendances.

Un cas intéressant de coexistence entre bibliothèques est celui qui inclue
plusieurs versions d'une même bibliothèque, car cela peut amener des problème
à la fois sur le système de fichier et durant l'exécution d'un processus utilisant
ces bibliothèques. Il y a aussi plusieurs utilités d'avoir plusieurs version
d'une même bibliothèque, cela permet de supporter des application qui dépend de
bibliothèques antérieurs.

Un autre application est de convertir un vieux format de fichier vers un format
plus récent. Dans le cas où il n'est pas possible de plusieurs version d'une bibliothèque
il faut alors écrire un \textit{reader} pour lire le vieux format manuellement ensuite le
utilise fonctions de la version cible de bibliothèque pour générer le nouveau format du fichier.
Cette solution à comme problème que le \textit{reader} est beaucoup moins testé que la
vielle version de la bibliothèque. Cela demande aussi de réécrire qu'est-ce qui à déjà été fait.

\begin{figure}[ht]
  \includegraphics[width=30em]{figures/app_convert_v1_to_v2.pdf}
  \caption{Un exemple d'application de conversion entre deux version d'un format
  de fichier comme sqlite2 et sqlite3 exploitant la possibilité de charger plusieurs
  version d'une bibliothèque.}
\end{figure}

L'architecture de processus sur un système permet plusieurs propriétés. La
robustesse, un processus failli les autres processus ne sont pas affectés. La
sécurité et l'isolation, chaque processus possède leur mémoire qui n'est pas
accessible par les autre processus et peuvent utilisé une version spécifique
des bibliothèques. Il est possible de concevoir l'architecture de processus en
utilisant des threads.  Un \textit{thread} décrit un courant d'exécution d'un
programme. Un processus à au minimum un \textit{thread} qui correspond au
courant d'exécution principal du programme. Les \textit{threads} sont utiles
pour paralléliser l'exécution d'un processus. La création de \textit{threads}
est beaucoup plus rapide que la création d'un processus, car elle ne nécessite
pas l'appel au système d'exploitation.

Ce modèle exploite la légèreté des \textit{threads} par rapport au processus et
la possibilité de charger plusieurs version des bibliothèques qu'il a besoin au sein
du système. Cela est similaire au modèle de processus utilisé par les
système d'exploitation, sauf que l'ensemble est juste au sein d'un seul processus.
Étant donnée que les \textit{threads} vivent tous au sein d'un même processus,
il est donc facile de partagé des informations d'un \textit{thread} à un autre.
Ce qui est plus difficile avec le modèle de processus, cela nécessite l'utilisation
mécanisme comme la mémoire partagé.

%\todo{picture: Thread as Light process}

% TODO: exemple de chemin.

%et s'il c'est un cas qui peut
%contenir un coexistence néfaste.  Cela n'est possible que s'il est possible de
%distinguer les deux version de la bibliothèque et aussi répartir les appels à
%des fonctions de même nom à la bonne version de la bibliothèque.


\subsection{Coexistence sur un système de fichiers}
La coexistence sur un même système de fichier implique que les deux
bibliothèques n'utilise pas le même espace physique et possède un chemin
différent pour les qualifier. Le choix de l'organisation des bibliothèques
dans le système de fichier ne permet pas toujours de conserver deux versions
d'une même bibliothèques.

La caractéristique que le système de bibliothèque doit avoir pour permettent
plusieurs version d'une bibliothèque est un organisation qui permet de distinguer
les différentes versions de la bibliothèque par un chemin unique.
La plupart des système de module ne distinguer pas les version d'un même module
et ne permette l'installation que d'une seul version. Les systèmes de module permettent
la gestion de différent préfixe dans lequel les modules sont installés. Chaque préfixe peut
contenir une version différente d'un même module. Pour avoir une nouvelle version d'un module,
il faut créer un nouveau préfixe.


%Le nombre de bibliothèque moyen dans un langage est d'environ 90000 \colorbox{red}{ref}
%en prennant en compte les gestionnaire de modules (bibliothèques) suivant:

% \todo{Include number of module in pm from www.modulecounts.com}

% Il est à noté que le nombre de bibliothèques qu'un langage possède est lié au nombre
% d'utilisateur. Aussi le nombre de bibliothèques n'est pas représentatif du nombre
% réellement utilisé.

\begin{figure}[h]
\begin{tabular}{|r|c|c|c|c|}
  \hline  & Environnement séparé & Multiple versions & Latest     \\\hline
  OCaml   & \checkmark           & \xmark            & default    \\\hline
  Python  & \checkmark           & \xmark            & default    \\\hline
  NodeJS  & \checkmark           & \xmark            & default    \\\hline
  Go      & \checkmark           & \xmark            & default    \\\hline
%  Gambit Scheme & \checkmark & \checkmark & default \\\hline
\end{tabular}
\caption{Comparaison de différent système de module.}
\end{figure}


\subsubsection{Organisation de OCaml}
Le système de gestion de bibliothèques d'OCaml se nomme OPAM. Ce système permet d'avoir
plusieurs environnement distinct contenant chacun un ensemble de version des bibliothèques.
Chaque environnement permet l'installation d'une version spécifique de chaque bibliothèque et
est étiqueté avec un nom choisit par l'utilisateur. Un changement d'environnement est
effectué par une requête de l'utilisateur \verb|opam switch <envname>|. Il utilise
le projet \textit{mancoosi}, un projet Européen de recherche dans le 7e cadre de recherche (FP7)
de la commission Européenne, pour gérer les contrainte de version, les dépendances optionnelles
et la gestion des conflits. L'environnement par défaut est lié aux dépôts standard d'OCaml.

\subsubsection{Organisation de Python}
L'organisation des bibliothèques Python ne permet de stocker que la dernière version
d'une bibliothèques. Les emplacements des bibliothèques sont modifiés par la variable d'environnement
\verb|PYTHONPATH| qui correspond dans python à la variable \verb|path| de la bibliothèque
interne \verb|sys|. Le système de bibliothèque de Python ne permet pas la coexistence de plusieurs
version de la même bibliothèque. Le \textit{package manager} principal de Python est \textit{pip}.
L'installation d'une autre version d'une bibliothèque désinstalle
ou masque la version déjà installé. Le système de module ne permet pas de référer à deux version
de la même bibliothèques.

\begin{figure}[ht]
    \begin{minipage}[t]{0.5\textwidth}
\begin{verbatim}
>>> import sys
>>> print('\n'.join(sys.path))
/usr/lib/python37.zip
/usr/lib/python3.7
/usr/lib/python3.7/lib-dynload
/home/username/.local/lib/python3.7/site-packages
/usr/lib/python3.7/site-packages
\end{verbatim}
    \end{minipage}
    \caption{L'ensemble des répertoires qui est utilisé par Python version 3.7
    pour organiser les bibliothèques sur un système de type Linux.}
\end{figure}

Python a le concept équivalent à OCaml de \textit{virtualenv} qui permet d'avoir plusieurs
versions installées sur la même machine. Cela permet de d'installer des
bibliothèques dans un environnement isolé des autre. L'avantage est qu'il est
possible d'avoir une compatibilité avec des logiciel qui utilise des version de
bibliothèques antérieur. Un inconvénient est qu'il n'y a pas un partage des
versions de bibliothèques communes entre les différent environnement, cela a
comme effet d'avoir plus d'un exemplaire d'une version de la bibliothèque installée
sur le système de fichier. Chaque \texttt{virtualenv} ne permet qu'une seule version de
chaque bibliothèque d'être installé.

%\todo{\hspace{2.5in}Image de coexistence venv}

\subsubsection{Organisation de NodeJS}
NodeJS est un interprète Javascript qui a été conçu pour être exécuté
du côté serveur dans un modèle client-serveur. Les bibliothèques sont
installé au niveau du projet. Cela implique que plusieurs projet qui
utilise la même version de la bibliothèque vont avoir la même exemplaire
de la bibliothèque.

La structure d'une bibliothèque dans NodeJS est décrit par un fichier
\texttt{package.json} qui contient plusieurs les méta données comme
le nom, la version, le nom des dépendances, la version des dépendances,
la licence sous laquelle la bibliothèque est publié et plusieurs autres
méta données lié à la bibliothèque. Sous NodeJS les bibliothèques sont gérer
par projet plutôt que globalement cela à comme avantage que chaque projet
fonctionne avec ses versions des bibliothèques.

\subsubsection{Organisation de Go}
L'organisation des bibliothèques dans Go est plus dans un
contexte environnement dont la racine est spécifier par la variable d'environnement \texttt{GOPATH}
avec un répertoire pour les exécutable compilé (\texttt{bin}),
un répertoire contenant le code source des différent projets (\texttt{src}) et un
répertoire pour les objets des modules installé (\texttt{pkg}). Chaque paire de système
d'exploitation et d'architecture a son propre répertoire dans \texttt{pkg}.

La structure du répertoire dans go
\todo{Refer to go help golang}
\begin{verbatim}
$GOPATH/
  - bin
    - ... binaries
  - src
    - github.com
      - UserName1
        - project1
        - project2
      - UserName2
        - projectA
        - projectB
  - pkg
    - linux_amd64
      - pkglist
        - objets
\end{verbatim}


%\subsubsection{Organisation dans Gambit Scheme}
%\todo{}
% exemple coexistence sur un système de fichier

\subsection{Coexistence au sein d'un processus}
L'autre type de coexistence entre les bibliothèques est durant l'exécution d'un
processus.  La coexistence entre des bibliothèques peuvent être positive ou
néfaste.  Un coexistence positive entre des bibliothèques est marqué par une
bonne répartition des appels de fonctions parmi ces bibliothèque.  Un appel à
la fonction \verb|foo| de la bibliothèque \verb|libA.so| ne va pas être
effectué dans la bibliothèque \verb|libB.so|. Deux bibliothèques ne coexiste
pas correctement au sein d'un processus si les appels de fonctions sont
réparties incorrectement parmi les bibliothèques. Le chargement des bibliothèques
diffère d'un langage interprété à un langage compilé nativement.

\subsubsection{Contexte interprété}
Les bibliothèques dans les langages interprétés utilisent leur propre procédure
de chargement de bibliothèque. Ce processus permet de charger directement les
fonctionnalité d'une bibliothèque à partir du code source.

La façon de charger le code source peut être effectué par une lecture de la
bibliothèque suivit d'un évaluation du code.

\begin{verbatim}
class Module(object):
    def __init__(self, members):
        for k in members.keys():
            setattr(self, k, members[k])

def importFile(name):
    with open(name, 'r') as fd:
        code=fd.read()
    env = {}
    exec(code, env)
    return Module(env)

\end{verbatim}

\subsubsection{Contexte natif}

%\section{Chargement dynamique}
Un des cas probables de deux bibliothèque avec les mêmes noms de fonctionnalité
sont deux versions différente de la même bibliothèque. Il existe des situations
dans lesquelles il serait intéressant d'avoir la possibilité de charger plusieurs
versions d'une bibliothèque.

Il y a dans un système dynamique qui permet de faire une mise à jour du
code sans nécessité un redémarrage du processus. Cet procédure ce nomme
\textit{hot-code-swapping}.

Il y a aussi dans un contexte ou le processus doit supporté plusieurs versions
d'un protocole fournit par une bibliothèque. Par exemple, un application qui migre
le format \textit{sqlite} au format \textit{sqlite3} doit pouvoir charge le fichier
dans le premier format et exporter toutes les tables dans le deuxième format.

\todo{Ajouté plus d'exemple}
