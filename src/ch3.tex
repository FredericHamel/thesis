
\chapter{Implémentation des modules}

La syntaxe des module se veut portable entre différente implémentation de
Scheme.  Gambit est un système qui se veut conforme R7RS.  La syntaxe choisit
pour les modules est celle qui utilise \lstcode{define-library} dans R7RS.
Cette forme offre plus de flexibilité que la forme \lstcode{library} dans R6RS.
Le standard R7RS est un simplification du standard R6RS qui offre des
fonctionnalités équivalentes.

Les format des modules R7RS construit par \lstcode{define-library} contient
plusieurs composantes. L'espace de nom du module qui regroupe toutes les
fonctionnalités. Une liste des modules qui sont utilisés par le module courant.
Une liste des symboles exportés par le module. Il est possible de modifier les
identifiant d'un module lors de l'importation et de l'exportation.
L'importation multiple d'un module doit correspondre à un seul chargement.
Pour exprimé les relations entre les modules certaines forme spéciale plus
simple ont été ajouté dans Gambit.  Si les concepteurs de librairies respectent
la syntaxe R7RS, alors il est possible de l'importer dans Gambit. C'est indépendant
du système dans lequel les librairies ont été écrit.



% Le format des modules nécessite plusieurs composantes.
% Chaque module a son propre espace de nom
% disjoint des autres modules. Un liste d'importation
% qui indique les dépendances entre les modules et permet
% l'interaction entre les modules. Certaines formes spéciales
% ont été ajouté dans pour pouvoir exprimer les relation entre
% les modules. Les modules R7RS permette de spécifier les identifiant
% d'un module et de les renommer. Les relations entre les modules doivent
% pouvoir être exprimées.  La liste des modules requis par le module
% courant et les modules publiés par le module courant.

% - Créer un espace pour les modules.
% - Spécifier les dépendence. (2)
% - Spécifier les paramètre de compilation.

\section{La forme \lstcode{\#\#namespace}}

Les espaces de nom sont gérer avec une forme spécial propre à Gambit. Cette
forme se nomme \lstcode{##namespace} et permet d'associer des identifiants à
d'autre.  Cette forme primitive est présente dans Gambit depuis longtemps.  Un
espace de nom se compose de n'importe quelle séquence de caractère terminé par
un \lstcode{#}. Il y a seulement l'espace de nom vide qui ne respecte pas cette
règle, c'est l'espace de nom par défaut.  Les associations de symbole données
par la forme \lstcode{##namespace} respecte la porté lexical. Il y a trois
types d'opération avec les espaces de nom.

Il y a les espaces de nom global qui s'applique à tous les symboles qui ne
contiennent pas de \lstcode{#}.
\begin{center}
  \lstset{language={scheme},frame=single,label=lst:forms->namespace-global,captionpos=b,caption={Namespace Global}}
  \begin{mplisting}{0.6}
(##namespace ("<ns>"))
;; <symbol-name> => <ns><symbol-name>
\end{mplisting}
\end{center}
Il est possible de spécifier la liste des symboles qui sont affectés par
la déclaration d'espace de nom. De la syntaxe \ref{lst:forms->namespace-global}
il suffit d'ajouter les symboles après le nom de l'espace de nom.\\
\begin{center}
  \lstset{language={scheme},
          frame=single,
          captionpos=b,
          caption={Namespace Set},
          label=lst:forms->namespace-set}
  \begin{mplisting}{0.6}
(##namespace ("<ns>" A B ...))
;; A => <ns>A
;; B => <ns>B
;; ...
\end{mplisting}
\end{center}
%Chaque symbole dans l'espace de nom peut être renommé à un nouveau symbole en
%spécifier une pair contenant l'association. La forme ressemble à l'exemple
La forme \lstcode{##namespace} permet aussi d'associer un identifiant à un
autre identifiant dans un espace de nom donné. Chaque association est marqué
par une pair qui alias le premier élément par le second. Par exemple, la pair
\lstcode{(<old> <new>)} remplace \lstcode{<old>} par \lstcode{<new>}.\\
\begin{center}
  \lstset{language={scheme},
          frame=single,
          captionpos=b,
          caption={Namespace Rename},
          label={lst:forms->namespace-rename}}
  \begin{mplisting}{0.6}
(##namespace ("<ns>" (<old> <new>) ...))
;; <old> => <ns><new>
;; ...
\end{mplisting}
\end{center}

% La syntaxe de la
% forme \lstcode{##namespace} qui inclus toutes les symboles dans l'espace de nom
% marqué par \lstcode{<ns>} est:

% \begin{center}
%   \begin{mplisting}{0.8}
% (##namespace ("<ns>"))
% \end{mplisting}
% \end{center}

% Il est possible de spécifier une liste des symboles qui appartiennent à
% l'espace de nom. Notez que seulement le espace de nom est entre guillemets.

% \begin{center}
%   \begin{mplisting}{0.8}
% (##namespace ("<ns>" sym1 ...))
% \end{mplisting}
% \end{center}


% L'utilisation de la forme \lstcode{##namespace} permet de associer plusieurs
% identifiant dans un espace de nom spécifique.  La procédure \lstcode{hello} est
% défini dans l'espace de nom \lstcode{hello#}.

%% XXX: namespace???
Cette forme est utilisé pour de créer un espace distinct pour chaque module.
Cela permet d'éviter les conflits de nom entre les identifiants des modules.
Chaque module commence par déclarer son espace de nom suivit des définitions
des procédures du module. Une déclaration d'espace de nom à l'une des forme
donné par \ref{lst:forms->namespace-global}, \ref{lst:forms->namespace-set}
ou \ref{lst:forms->namespace-rename}.
\\
\begin{center}
  \lstset{language={scheme},
          frame=single,
          captionpos=b,
          caption={Module Hello},
          label={lst:namespace->hello}}
\begin{mplisting}{0.6}
;; hello.scm
(##namespace ("hello#" hello))
(define (hello)
  (display "Hello, world!\n"))
(hello)
\end{mplisting}
\end{center}
L'exemple \ref{lst:namespace->hello} est un exemple d'utilisation de la forme
\lstcode{##namespace} dans pour créer un espace pour le module \lstcode{hello}.
La procédure \lstcode{hello} est dans l'espace de nom \lstcode{hello#}.

\section{La forme \lstcode{\#\#demand-module} et \lstcode{\#\#supply-module}}

Le mécanisme de chargement des modules est géré par la forme spéciale
\lstcode{##demand-module}. Cette forme indique au système de charger un module
s'il n'est pas déjà chargé. Cette forme gère le chargement multiple d'un
module. Elle est utilisé pour pour importer la liste des modules requis par le
module courant.  Le fonctionnement de cette forme est similaire à la procédure
\lstcode{load} avec quelque différence. La forme \lstcode{##demand-module} est
une macro qui génère une expression vide. L'effet de cette forme agit après la
phase d'expansion des macros. Le paramètre passé à \lstcode{##demand-module}
doit être un symbole qui correspond au nom du module. La procédure \lstcode{load}
requière le chemin complet vers le fichier à charger.


Il est à noter que l'ordre des \lstcode{##demand-module} correspond à l'ordre
que les modules vont être visité. Cette forme agit peut importe sont emplacement
ou l'expansion de macros est appliquée.

%% Review.

% \begin{center}
%   \begin{mplisting}{0.9}
% (##demand-module A)
% (##demand-module A)
% (##demand-module B)
% \end{mplisting}
% \end{center}

Un forme spéciale conjointe au \lstcode{##demand-module} indique le nom
symbolique des modules importés des modules exportés. Cette forme spéciale est
\lstcode{##supply-module} Elle accepte comme paramètre le nom du module exporté
par l'unité courant.  La syntaxe de ces deux formes dans le listing
\ref{lst:syntax->demand/supply-module}.\\
\begin{center}
  \lstset{language={scheme},
          frame=single,
          captionpos=b,
          caption={Syntaxe \lstcode{demand-module} et \lstcode{supply-module}},
          label={lst:syntax->demand/supply-module}}
  \begin{mplisting}{0.8}
(##demand-module %*\textit{<module-ref>}*)
(##supply-module %*\textit{<module-ref>}*)
\end{mplisting}
\end{center}

\subsection{Les Méta Informations}
Un module a des informations qui sont utilisées lors de l'expansion
et même la compilation. Ces informations sont spécifier par la forme
\lstcode{##meta-info}. Cette forme accepte au moins un paramètre qui
est le nom de la méta information, le reste des paramètres est la valeur
associer à la méta donnée.

\begin{center}
  \begin{mplisting}{0.5}
(##meta-info %*\textit{<name>}* %*\textit{<value>}*)
(##meta-info %*\textit{<name>}* %*\textit{<value>}* ...)
\end{mplisting}
\end{center}

Les méta informations sont utilisés pour donner des paramètres de compilation
du module. Les différents méta informations sont \lstcode{cc-options},
\lstcode{ld-options}, \lstcode{ld-options-prelude}, \lstcode{pkg-config}
et \lstcode{pkg-config-path}. Ces méta informations ne sont utile que pour les modules
compilés.

\begin{itemize}
  \item Les \lstcode{cc-options} sont ajouter au options de la commande qui
    invoque le compilateur C.

  \item Les méta informations \lstcode{ld-options} et \lstcode{ld-options-prelude}
    ajoute les paramètres à la commande qui invoque l'éditeur de lien.
    Les paramètres dans \lstcode{ld-options-prelude} précèdent ceux
    qui sont dans \lstcode{ld-options}.

  \item \lstcode{pkg-config} contient le nom des bibliothèques C à être
    lié au module Scheme. Les options nécessaires pour au compilateur
    C sont déterminés automatiquement par l'utilitaire \lstcode{pkg-config}.

  \item \lstcode{##pkg-config-path} ajoute des répertoires à la variable d'environnement
    \lstcode{PKG_CONFIG_PATH} qui est utilisée par l'utilitaire \lstcode{pkg-config}.

\end{itemize}

\section{Implémentation des modules primitifs}

Un module primitif est généralement constitué d'un fichier d'entête avec la
déclaration de l'espace de nom et les définitions de macros et un fichier
contenant les procédure. Dans Gambit les fichiers d'entête sont marqués par un
\lstcode{#} juste avant l'extension.

\begin{itemize}
  \item \texttt{\textit{<name>}\#.scm} est la structure du nom fichier d'entête.
    Ce fichier contient des déclaration d'espace de nom et des
    définitions de macros.

  \item \texttt{\textit{<name>}.scm} est la structure du nom du fichier qui contient
    les procédures du module.

\end{itemize}

Le nom des fichier doit correspondre à la dernier partie du nom de module.  Par
exemple, le module primitif \lstcode{angle2} doit inclure les fichiers
\lstcode{angle2/angle2.scm} et généralement \lstcode{angle2/angle2#.scm}.\\
\begin{center}
  \lstset{language={scheme},frame=single}
\begin{mplisting}{0.9}
;; angle2/angle2#.scm
(##namespace ("angle2#" deg->rad rad->deg))
\end{mplisting}\\[4ex]
  \lstset{caption={Écriture d'un module qui implémente une pile. Ce module est
            séparé en 2 fichiers. Le fichier \texttt{stk\#.scm} qui contient les
            exportations et \texttt{stk.scm} qui contient les implémentations des
            fonctions.},
          captionpos=b,
          label={lst:module->angle}}
\begin{mplisting}{0.9}
;; angle2/angle2.scm
(include "angle2#.scm")
(##namespace ("angle2#" factor))
(##supply-module angle2)
(define factor (/ (atan 1) 45))
(define (deg->rad x) (* x factor))
(define (rad->deg x) (/ x factor))
\end{mplisting}
\end{center}

% XXX: END implementation
%\todo{Continuer ici}

%\begin{center}
%  \begin{figure}[h]
%  \begin{tabular}{|l|l|}
%\hline
%\begin{mplisting}{0.5}
%;; Library
%(library (math)
%  (export fact)
%  (import (rnrs base))
%  (define (fact n)
%    (if (< n 2)
%      1
%      (* n (fact (- n 1))))))
%\end{mplisting} &
%\begin{mplisting}{0.5}
%;; Main program
%(import
%  (rnrs base)
%  (rnrs io simple)
%  (math))
%
%(display (fact 5))
%(newline)
%\end{mplisting}\\\hline
%  \end{tabular}
%\caption{À gauche, il y a un exemple d'une bibliothèque mathématique dans le format R6RS qui implémente
%la fonction factoriel. À droite, un exemple d'importation de la bibliothèques qui utilise la forme
%spéciale \texttt{import}.}
%\end{figure}
%\end{center}

Dans l'exemple \ref{lst:module->angle}, il y a dans \lstcode{angle2/angle2.scm} l'inclusion
de du fichier d'entête \lstcode{angle2/angle2#.scm} qui ajoute une déclaration d'espace
de nom redondante dans ce cas.  La déclaration \lstcode{(##namespace ("angle2#"))}
implique l'espace de nom ajouté par l'inclusion du fichier d'entête. Il est
possible que l'espace de nom déclaré dans \lstcode{angle2/angle2#.scm} ne corresponde
pas à celui utilisé dans \lstcode{angle2/angle2.scm}.

La forme \lstcode{##namespace} dans l'example \ref{lst:module->angle}
s'applique aux identifiants suivant:
\begin{center}
  \lstset{language={scheme},keepspaces=true}
  \begin{mplisting}{0.3}
factor    --> stk#factor
deg->rad  --> stk#deg->rad
rad->deg  --> stk#rad->deg
\end{mplisting}
\end{center}

\subsection{La forme \lstcode{\#\#import}}
%
L'importation des modules est effectué par la forme \lstcode{##import} qui
effectue deux actions, l'inclusion du fichier \lstcode{<name>#.scm} et un
chargement des définitions.  La forme \lstcode{##import}, comme
\lstcode{##demand-module} s'occupe de trouver l'emplacement du fichier d'entête
à partir du nom du module. Elle génère le \lstcode{##include} du fichier
d'entête s'il existe et un \lstcode{##demand-module} du module.  L'importation
\lstcode{(##import angle2)} est équivalent à:

\begin{center}
  \lstset{%
    caption={Expansion de \lstcode{(\#\#import angle2)}},
    captionpos=b,
    label={lst:prim-import->stk}}
  \begin{mplisting}{0.9}
(##include "/un/chemin/angle2/angle2#.scm")
(##demand-module stk)
\end{mplisting}
\end{center}


\section{Implémentation des modules R7RS}
% XXX: Implémentation
Pour que le système de module soit compatible avec d'autre implémentation
Scheme,  les modules haut niveau sont défini dans le standard R7RS
Small~\cite{Scheme:R7RS}. Les modules sont définis par la forme
\lstcode{define-library} la syntaxe est donnée par le
listing~\ref{lst:syntax->define-library}. Les forme \lstcode{define-library} et
\lstcode{import} utilisé les formes spéciales utilise par les modules
primitifs. L'élément qui distingue un module primitif et un module R7RS
est l'utilisation de la forme \lstcode{define-library}.

\subsection{Expansion du \lstcode{import}}
\label{sec:import-expand}

La façon que la forme \lstcode{import} est expansé dépend du type de module qui
est importé. L'importation d'un module primitif est différent de l'importation
d'un module R7RS. Gambit permet l'importation d'un module primitif en utilisant
la même forme que pour les modules R7RS. Les capacités du \lstcode{import}
dépendent s'il est d'un \lstcode{define-library} d'un programme principal. Dans
le cas d'un \lstcode{define-library} le \lstcode{import} supporte l'importation
relatif, qui est un extension de Gambit.


\subsubsection{Importation d'un module primitif}
L'importation d'un module primitif limite la syntaxe du \lstcode{import}.
Il n'est pas possible d'utiliser les extensions \lstcode{only}, \lstcode{except}
et \lstcode{rename} sur un module primitif présentement. Le \lstcode{import} R7RS se rabat
sur le \lstcode{##import} des modules primitifs qui ne supporte pas les extensions R7RS.
Cela permet d'utiliser des modules primitifs dans un contexte R7RS.\\
\begin{center}
  \lstset{language={scheme},captionpos=b,frame=single,
          label={lst:import->expand-primitive},
          caption={Expansion du \texttt{import} d'un module primitif}}
\begin{mplisting}{0.8}
;; expansion of (import (termite))
(##import termite)
\end{mplisting}
\end{center}

\subsubsection{Importation d'un module R7RS}

L'importation d'un module R7RS est expansé en au plus trois parties.  Un
\lstcode{##demand-module} qui s'occupe de charger l'implémentation des
procédures du module. Une déclaration de d'espace de nom qui donne accès au
identifiants que le module exporte. L'implémentation des macros qui sont
exporté du module.

L'instruction de chargement du module est générer dans tous les cas qu'un
module définit des procédures. Un module qui ne définit que des macros ne
nécessite pas d'être charger durant l'exhowdy seulement dans le contexte
d'expansion des macros. L'importation d'un module R7RS qui ne contient qu'une
déclaration \lstcode{export} ne nécessite pas d'être chargé durant l'exécution.
Ce type de module est utilisé pour exporter les fonctionnalité déjà implémenté
dans Gambit dans un contexte R7RS.

La forme utilisé pour rendre disponible à l'ensemble identifiants importés est
\lstcode{##namespace}. L'ensemble des identifiants importés dépend de la forme
du \lstcode{import}. Par défaut, tous les identifiant, exporté par le module,
sont importés.  Les opérateurs \lstcode{only} et \lstcode{except} affectent le
nombre d'identifiant importé. Les opérateurs \lstcode{prefix} et
\lstcode{rename} affecte le nom des identifiants.  Dans l'exemple
\ref{lst:import->expand-r7rs}, l'importation inclut l'ensemble des identifiants
exporté par le module. L'ensemble des formes \lstcode{##namespace} générées
par un \lstcode{import} est donnée par le listing~\ref{lst:import->expand-r7rs-namespace}.
\\

\begin{center}
  \lstset{language={scheme},captionpos=b,frame=single,
          label={lst:import->expand-r7rs},
          caption={L'exemple de l'expansion du \texttt{import} du module R7RS
            \lstcode{github.com/gambit/hello} qui exporte les procédures
            \lstcode{hello} et \lstcode{hi}}}
  \begin{mplisting}{1}
;; expansion of (import (github.com/gambit/hello))
(##demand-module github.com/gambit/hello)
(##namespace ("github.com/gambit/hello#" hi salut))
;; macros
\end{mplisting}
\end{center}

% TODO: Différent namespaces généré par import.

\begin{center}
  \lstset{language={scheme},captionpos=b,frame=single,
          label={lst:import->expand-r7rs-namespace},
          caption={Différent \lstcode{\#\#namespace} généré par
            l'expansion du \texttt{import} d'un module R7RS.}}
  \begin{mplisting}{1}
;; (import (only (github.com/gambit/hello) hi))
(##namespace ("github.com/gambit/hello#" hi))

;; (import (except (github.com/gambit/hello) hi))
(##namespace ("github.com/gambit/hello#" salut))

;; expansion of (import (prefix (github.com/gambit/hello) m-))
(##demand-module github.com/gambit/hello)
(##namespace ("github.com/gambit/hello#" (m-hi hi) (m-salut salut)))

;; (import (rename (github.com/gambit/hello) (hi bonjour)))
(##namespace ("github.com/gambit/hello#" (howdy hi) salut))
\end{mplisting}
\end{center}


\subsection{Expansion du \lstcode{define-library}}

La forme \lstcode{define-library} est expansé dans les formes qui composent un
module primitif. Chacune des déclarations de la bibliothèque est utilisée dans
l'expansion du \lstcode{define-library}. La déclaration d'exportation est
valide si toutes les identifiants exportés sont distincts. Une déclaration
\lstcode{export} qui exporte un identifiant plusieurs fois cause une erreur de
syntaxe. Les informations les identifiant exporté ne sont pas utilisé lors
l'expansion du \lstcode{define-library}, mais lors de l'importation de cette
bibliothèque.  Les déclarations \lstcode{import} sont expansées de la même
façons que dans contexte des programmes principaux.\\

\begin{center}
  \lstset{language={scheme},captionpos=b,frame=single,
          label={lst:define-library->expand},
          caption={C'est le code source du module \lstcode{github.com/gambit/hello}
            avant l'expansion.}}
\begin{mplisting}{0.9}
(define-library (hello)
  (import (scheme base) (scheme write))
  (export hi salut)
  (begin
    (define (exclaim msg1 msg2)
      (display msg1)
      (display msg2)
      (display "!\n"))
    (define (hi name) (exclaim "hello " name))
    (define (salut name) (exclaim "bonjour " name))
    ;; it is best for a library to not have side-effects...
    #;(salut "le monde")))
\end{mplisting}
  \vspace*{4ex}
  \lstset{language={scheme},captionpos=b,frame=single,
          label={lst:define-library->expand2},
          caption={Expansion de la forme \lstcode{define-library}
            du module \lstcode{github.com/gambit/hello}.}}
  \begin{mplisting}{0.9}
;; expansion of (define-library (hello) ...)
(##declare (block))
(##supply-module github.com/gambit/hello)
(##namespace ("github.com/gambit/hello#"))
(##namespace ("" define ...))
(##namespace ("" write-shared write display write-simple))
(define (exclaim msg1 msg2)
    (display msg1) (display msg2) (display "!\n"))
(define (hi name) (exclaim "hello " name))
(define (salut name) (exclaim "bonjour " name))
(##namespace (""))
\end{mplisting}
\end{center}

\subsubsection{Extensions de Gambit}

Gambit offre des extensions au \lstcode{define-library} et au \lstcode{import}.
L'importation dans le contexte d'une bibliothèques peut être relatif au module
courant. Plusieurs déclarations supplémentaires ont été ajouté dans la forme
\lstcode{define-library}.

\begin{itemize}
  \item \lstcode{namepase}
  \item \lstcode{cc-options}
  \item \lstcode{ld-options} et \lstcode{ld-options-prelude}
  \item \lstcode{pkg-config} et \lstcode{pkg-config-path}
\end{itemize}


Le listing~\ref{lst:relative-import} est un exemple d'importation
relatif.  L'importation relatif part:w
du \lstcode{module-ref} du module courant.
Un \lstcode{import} de \lstcode{(.. C)} à partir du module \lstcode{(A B)}
correspond à l'importation de \lstcode{(A C)}. C'est pour permettre au sous
module de tests unitaires de référer au module principal.\\

\begin{center}
  \lstset{language={scheme},
          frame=single,
          captionpos=b,
          caption={Importation relatif du module \lstcode{(A C)}},
          label={lst:relative-import}}
  \begin{mplisting}{0.8}
(define-library (A B)
  ;; => (import (A C))
  (import (.. C)))
\end{mplisting}
\end{center}

La déclaration \lstcode{namespace} permet de forcer l'espace de nom d'un module.
L'utilisation primaire de cette déclaration est l'implémentation de modules qui
exporte les fonctionnalités déjà implémentées dans Gambit. \\

\begin{center}
  \lstset{language={scheme},
          frame=single,
          captionpos=b,
          caption={Implémentation de la bibliothèques système \lstcode{(scheme case-lambda)}.},
          label={lst:module->scheme/case-lambda}}
  \begin{mplisting}{0.8}
(define-library (scheme case-lambda)
  (namespace "")
  (export
case-lambda
))
\end{mplisting}
\end{center}

Les déclarations \lstcode{cc-options}, \lstcode{ld-options}, \lstcode{ld-options-prelude},
\lstcode{pkg-config} et \lstcode{pkg-config-path} permet d'ajouter des éléments dans les
méta informations respectifs.
