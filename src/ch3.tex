
\chapter{Implémentation des modules}

Les format des modules R7RS construit par \lstcode{define-library} contient
plusieurs composantes. L'espace de nom du module qui regroupe toutes les
fonctionnalités. Une liste des modules qui sont utilisés par le module courant.
Une liste des symboles exportés par le module.  Les modules R7RS construit par
\lstcode{define-library} permettent de spécifier une transformation sur les
identifiants d'un module durant l'importation et aussi durant l'exportation.
L'importation d'un module doit être effectué une seul fois, même si présent
plusieurs fois.  Pour exprimé les relations entre les modules certaines forme
spéciale plus simple ont été ajouté dans Gambit.

% Le format des modules nécessite plusieurs composantes.
% Chaque module a son propre espace de nom
% disjoint des autres modules. Un liste d'importation
% qui indique les dépendances entre les modules et permet
% l'interaction entre les modules. Certaines formes spéciales
% ont été ajouté dans pour pouvoir exprimer les relation entre
% les modules. Les modules R7RS permette de spécifier les identifiant
% d'un module et de les renommer. Les relations entre les modules doivent
% pouvoir être exprimées.  La liste des modules requis par le module
% courant et les modules publiés par le module courant.

% - Créer un espace pour les modules.
% - Spécifier les dépendence. (2)
% - Spécifier les paramètre de compilation.

\section{Formes spéciales}

Les espaces de nom sont gérer avec une forme spécial propre à Gambit. Cette
forme se nomme \lstcode{##namespace} et permet associer des identifiant à un
espace de nom. Cette forme primitive était présente dans Gambit depuis
plusieurs versions.  Un espace de nom se compose de n'importe quelle séquence
de caractère terminé par un \lstcode{#}. Il y a seulement l'espace de nom vide
qui ne termine pas par le caractère \lstcode{#}, c'est l'espace de nom par
défaut.  Les associations de symbole donné par la forme \lstcode{##namespace}
utilise une porté lexical. La syntaxe de la forme \lstcode{##namespace} qui
inclus toutes les symboles dans l'espace de nom marqué par \lstcode{<ns>} est:

\begin{center}
  \begin{mplisting}{0.8}
(##namespace ("<ns>#"))
\end{mplisting}
\end{center}

Il est possible de spécifier une liste des symboles qui appartiennent à
l'espace de nom. Notez que seulement le espace de nom est entre guillemets.

\begin{center}
  \begin{mplisting}{0.8}
(##namespace ("<ns>" sym1 ...))
\end{mplisting}
\end{center}

La forme \lstcode{##namespace} permet aussi d'associer un identifiant à un
autre identifiant dans un espace de nom donné. Chaque association est marqué
par une pair qui alias le premier élément par le second. Par exemple, la pair
\lstcode{sym1 new-sym1} alias \lstcode{sym1} par \lstcode{new-sym1}.

\begin{center}
  \begin{mplisting}{0.6}
(##namespace ("<ns>" (sym1 new-sym1) ...))
\end{mplisting}
\end{center}

% L'utilisation de la forme \lstcode{##namespace} permet de associer plusieurs
% identifiant dans un espace de nom spécifique.  La procédure \lstcode{hello} est
% défini dans l'espace de nom \lstcode{hello#}.

% \begin{center}
% \begin{mplisting}{0.6}
% (##namespace ("hello#" hello))
% (define (hello)
%   (display "Hello, world!\n"))
% \end{mplisting}
% \end{center}


Le mécanisme de chargement des modules est géré par la forme spéciale
\lstcode{##demand-module}. Cette forme indique au système de charger un module
s'il n'est pas déjà chargé. Cette forme gère le chargement multiple d'un
module. Elle est utilisé pour pour importer la liste des modules requis par le
module courant.  Le fonctionnement de cette forme est similaire à la procédure
\lstcode{load} avec quelque différence. La forme \lstcode{##demand-module} est
une macro qui génère une expression vide. L'effet de cette forme agit après la
phase d'expansion des macros. Le paramètre passé à \lstcode{##demand-module}
doit être un symbole qui correspond au nom du module. La procédure \lstcode{load}
requière le chemin complet vers le fichier à charger.

\begin{center}
  \begin{mplisting}{0.8}
(##demand-module %\textit{<module>}*)
\end{mplisting}
\end{center}

Il est à noter que l'ordre des \lstcode{##demand-module} correspond à l'ordre
que les modules vont être visité. Cette forme agit peut importe sont emplacement
ou l'expansion de macros est appliquée.

%% Review.

% \begin{center}
%   \begin{mplisting}{0.9}
% (##demand-module A)
% (##demand-module A)
% (##demand-module B)
% \end{mplisting}
% \end{center}

Un forme spéciale conjointe au \lstcode{##demand-module} indique le nom
des modules exportés par un unité. Cette forme spéciale est \lstcode{##supply-module}
Elle accepte comme paramètre le nom du module exporté par l'unité courant.
La syntaxe est identique au \lstcode{##demand-module}.

\begin{center}
  \begin{mplisting}{0.8}
(##supply-module %*\textit{<module>}*)
\end{mplisting}
\end{center}

\section{Implémentation des modules de base}

Un module de base est constitué d'un fichier d'entête avec la déclaration
de l'espace de nom et les définitions de macros et un fichier contenant
les procédure. Dans Gambit les fichiers d'entête sont marqués par un \lstcode{#}
juste avant l'extension.

\begin{itemize}

  \item \lstcode{<name>#.scm} est la structure du nom fichier d'entête.
    Ce fichier contient des déclaration d'espace de nom et des
    définitions de macros.

  \item \lstcode{<name>.scm} est la structure du nom du fichier qui contient
    les procédures du module.

\end{itemize}

Le nom \lstcode{<name>} représentante la dernière partie du nom du module. Par
exemple, le module \lstcode{gambit/tar} utilise le nom \lstcode{tar} dans le
nom du fichier d'entête et du fichier qui contient les définitions.

\todo{Continuer ici}

% Gambit offre un mécanisme pour aider a minimiser les conflits de nom. Ce
% mécanisme permet d'associer un identifiant à un autre avec la forme spécial
% \lstcode{##namespace}.  L'appel à \lstcode{(##namespace ("foo#" A B))} indique
% qu'une référence futur à \lstcode{A} devient une référence à
% \lstcode{foo#A} et l'un à \lstcode{B} devient une à \lstcode{foo#B}. Le espace
% de nom dans lequel \lstcode{A} et \lstcode{B} est \lstcode{foo#}.
En utilisant cette structure, un module peut être écrit comme suit:

\begin{center}
  \begin{figure}[h]
  \begin{tabular}{|l|}
\hline
\begin{mplisting}{0.5}
;; math#.scm
(##namespace ("math#" fact fib))
\end{mplisting} \\\hline
\begin{mplisting}{0.6}
;; math.scm
(##supply-module math)
(##namespace ("math#" fact fib))
(define (fib n)
  (if (< n 2)
    n
    (+ (fib (- n 1)) (fib (- n 2)))))
(define (fact n)
  (if (< n 2)
    1
    (* n (fact (- n 1)))))
\end{mplisting}\\\hline
  \end{tabular}
  \caption{Écriture d'un petit module mathématique qui implémente les fonctions \lstcode{fact}
    et \lstcode{fib}. Ce module est séparé en 2 fichiers, \texttt{math\#.scm} est un fichier
    contenant les déclarations de l'espace de noms et des définitions de macros que le module
    exporte.}
  \label{fig:math_module1}
\end{figure}
\end{center}
% XXX: END implementation

%\begin{center}
%  \begin{figure}[h]
%  \begin{tabular}{|l|l|}
%\hline
%\begin{mplisting}{0.5}
%;; Library
%(library (math)
%  (export fact)
%  (import (rnrs base))
%  (define (fact n)
%    (if (< n 2)
%      1
%      (* n (fact (- n 1))))))
%\end{mplisting} &
%\begin{mplisting}{0.5}
%;; Main program
%(import
%  (rnrs base)
%  (rnrs io simple)
%  (math))
%
%(display (fact 5))
%(newline)
%\end{mplisting}\\\hline
%  \end{tabular}
%\caption{À gauche, il y a un exemple d'une bibliothèque mathématique dans le format R6RS qui implémente
%la fonction factoriel. À droite, un exemple d'importation de la bibliothèques qui utilise la forme
%spéciale \texttt{import}.}
%\end{figure}
%\end{center}

La forme \lstcode{##namespace} dans l'exemple du module \lstcode{math} est
utilisé pour créer un espace de nom pour contenir les identifiant \lstcode{fact}
et \lstcode{fib}. Le \lstcode{##supply-module} indique au système Gambit que
le unité \lstcode{math.scm} fournit le module \lstcode{math}.

Ce module peut être importé par la forme \lstcode{##import}. L'importation
est fait en deux parties, l'inclusion du fichier \lstcode{<name>#.scm} et
un chargement des définitions par \lstcode{##demand-module}. L'importation
\lstcode{(##import math)} est équivalent à:

\begin{center}
  \begin{mplisting}{0.9}
  (##include "math/math#.scm")
  (##demand-module math)
  \end{mplisting}
\end{center}

La forme \lstcode{##import} s'occupe de trouver l'emplacement du fichier
d'entête à partir du nom du module. Elle génére le \lstcode{##include} du
fichier d'entête s'il existe et un \lstcode{##demand-module} du module.

Cette forme est utilisé affin de créer un espace distinct pour chaque module.
Cela permet d'éviter les conflits de nom entre les identifiants utilisé au sein
des modules.  Chaque module commence par déclarer son espace de nom suivit des
définitions des procédures du module.  Une déclaration d'espace de nom à la
forme suivante \lstcode{(##namespace ("<name>#"))}. La partie \lstcode{<name>}
de la forme \lstcode{##namespace} doit être un chaine d'au moins un caractères.
Toutes les caractères sont permis.

\begin{center}
  \begin{tabular}{|l|}
\hline
\begin{mplisting}{0.6}
;; example.scm
(##namespace ("example#" hello))
(define (hello)
  (display "Hello, world!\n"))
(hello)
\end{mplisting}\\\hline
  \end{tabular}
\end{center}
L'exemple ci-dessus est un exemple d'utilisation de la forme \lstcode{##namespace}
dans pour créer un espace pour le module \lstcode{example}. La procédure \lstcode{hello}
est définit dans l'espace de nom \lstcode{example#}.

\section{Implémentation des modules R7RS}
% XXX: Implémentation
