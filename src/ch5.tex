
\chapter{Gestion des modules}
\label{ch:module_management}

% TODO: too much detail in intro
%       il ne faut pas faire un sommaire du carteau du chapitre, mais motiver
%       l'existance de ce chapitre
%       et mentionner ce dont tu va parler et pourquoi (le lien avec ce travail)

Ce chapitre décrit l'organisation des modules sur le système de fichier pour
permettre plusieurs versions d'un module. Notre approche est d'associer à
chaque version d'un module un répertoire différent. Cela permet de stocker les
différentes versions d'un module dans le système de fichier.  Nous avons
comparé les différentes façons d'organiser les modules dans plusieurs langages
comme Python, JavaScript, Go, OCaml. Il est important que l'installation d'un
module n'altère pas le bon fonctionnement des autres modules.  Le modèle de gestion des
modules choisi garantit que les dépendances d'un module sont fixes.

\section{Sommaire}
% Installation, Désinstallation, Mise à jour, Compilation/Exécution
La gestion des modules inclut généralement l'installation, la mise à jour et
la désinstallation. L'organisation des modules est un élément important
dans la gestion des modules. Les gestionnaires de modules sont présents dans
beaucoup de langages tels que Python, Ruby, JavaScript, Common Lisp, Go, etc.
Un gestionnaire de module est inclus dans le système Gambit Scheme pour
organiser les modules.

Le gestionnaire de module de Gambit Scheme fournit les opérations
d'installation, de désinstallation, de mise à jour, de compilation
d'un module et l'exécution des tests unitaires du module. Les modules
sont versionnés par Git. L'emplacement des modules est spécifié par
une liste de répertoires qui inclut les modules système et les modules
utilisateur. La gestion des modules est effectuée par le module \lstcode{_pkg}
qui offre les procédures d'installation d'installation et de désinstallation.


% % quicklisp.org
% Les gestionnaires de module permettent plusieurs opérations sur les modules
% comme l'installation, la mise à jour et la désinstallation. La gestion inclut
% l'organisation des versions des modules sur le système de fichier. Beaucoup de
% de langages ont au moins un gestionnaire de modules. Le langage Python a le
% gestionnaire de module \textbf{pip}. L'implémentation NodeJS pour Javascript à
% le gestionnaire de module \textbf{npm}. Le langage Common Lisp a le gestionnaire
% \textit{quicklisp}.

% Les gestionnaires de module utilisent une hiérarchie de répertoires pour
% organiser les modules. Il existe plusieurs façon pour gérer les modules.
% Certain permette plusieurs versions d'un module dans un même environnement,
% comme dans le langage Go.

% Les module Gambit sont situés dans des répertoires spécifié dans le
% \lstcode{search-order}. Par défaut, il y a un répertoire pour les modules
% systèmes\ref{modules_systems} et un répertoire pour les modules
% utilisateurs\ref{modules_utilisateurs}. Ces répertoires sont associés au
% répertoire d'installation de Gambit. Les répertoires d'installation sont
% dénotés par un préfixe \lstcode{\~\~}.  Le modules système utilise utilise par
% défaut le répertoire d'installation \lstcode{\~\~lib} alors que les modules
% utilisateurs utilise le répertoire \lstcode{\~\~userlib}. Chaque module peut
% être installé, désinstallé, testé et compilé. La plupart de ces opérations est
% faite par le module gambit \lstcode{_pkg}.  Il est possible d'invoquer ces
% opérations par des arguments de ligne de commande passé à Gambit.

\section{Organisation des modules}

Les modules sont organisés dans des répertoires donnés par le système Gambit.
Ils contiennent l'ensemble des modules internes et actuellement installés sur
le système. Il y a trois principaux répertoires spéciaux qui contiennent des
modules.

\begin{itemize}
  \item \lstcode{\~\~userlib}: c'est le répertoire qui contient les modules
    de l'utilisateur, par défaut \texttt{.gambit\_userlib} dans le répertoire
    maison de l'utilisateur.

  \item \lstcode{\~\~lib}: c'est le répertoire d'installation de Gambit
    qui contient les modules système. Les modules dans ce répertoire sont
    communs à tous les utilisateurs.

  \item \lstcode{\~\~instlib}: c'est le répertoire d'installation des modules.
    Par défaut, il correspond au répertoire \lstcode{\~\~userlib}.
\end{itemize}

Un module local ou hébergé est identifié de façon unique par un
\lstcode{module-ref}.  Un \lstcode{module-ref} est séparé en trois parties: le
\lstcode{hostname}, le \lstcode{path} et l'étiquette qui donne la version.  La
différence entre une référence à un module local et hébergé est la première
partie. Dans le cas hébergé, le champ \lstcode{hostname} contient l'information
du nom de domaine qui, dans le cas local, est vide.  Le \lstcode{<tag>}
spécifie la version du module avec une référence à un commit du système de
révision Git. Un \lstcode{<tag>} vide réfère à la version de développement du
module (à éviter pour le déploiement final).  La syntaxe du nom de domaine est
donnée par la grammaire[\ref{lst:hostname->grammar}].  La grammaire
formelle~\ref{lst:module-ref->grammar} décrit la syntaxe du
\lstcode{<module-ref>} dans le cas hébergé et local.\\

\begin{figure}[ht]
  \lstset{frame=single}
  \begin{mplisting}{0.8}
<module-ref> := <local> | <hosted>
<local>      := <id>(/<id>)*<tag>
<hosted>     := <hostname>/<id>/<id>(/<id>)*(@<tag>)?
\end{mplisting}
  \caption{Grammaire formelle}
  \label{lst:module-ref->grammar}
\end{figure}

Le \lstcode{module-ref} \lstcode{github.com/gambit/hello} réfère
au module \lstcode{hello} sur le serveur de révision \lstcode{github.com}
dans l'espace \lstcode{gambit}. Le champ \lstcode{host} est dans ce
cas \lstcode{github.com/gambit} qui correspond au nom de domaine avec
le nom de l'espace sur le serveur.

% \begin{itemize}
%   \item \lstcode{install} effectue l'installation de modules.
%   \item \lstcode{update} effectue la mise à jour de la cache des modules demandés. Cela
%     permet d'actualiser les nouvelles versions disponible d'un module.
%   \item \lstcode{uninstall} désinstalle les modules spécifié.
%   \item \lstcode{test} exécute les tests unitaires des modules spécifiés.
% \end{itemize}

\subsection{Installation de module}
L'installation des modules peut être soit à partir d'un serveur de révision
ou d'un répertoire local versionné par git. Dans les deux cas d'installation,
le \lstcode{module-ref}  est utilisé pour déterminer l'emplacement du module
dans le répertoire des modules. Chaque \lstcode{module-ref} est associé à un
répertoire unique dans le répertoire des modules.

% Les modules qui sont hébergés sur un serveur de révision comme github, gitlab, bitbucket,
% etc ont un \lstcode{module-ref} distinct.

% L'organisation des module doit permettre l'installation de plusieurs
% version d'un même module. C'est pour cela qu'il sont organisés dans une
% hiérarchie de répertoire lié au \lstcode{module-ref} du module.
% Chaque version d'un module est identifié par un seul \lstcode{module-ref}
% qui est associé à un seul emplacement sur le système de fichier.

% L'organisation des répertoires des modules permet l'installation de plusieurs
% versions d'un même module. Cela garantie que tous les modules qui utilise une
% version antérieur de modules fonctionne toujours. Certains systèmes de module
% ne conserve qu'une seul version de chaque module. La mise à jour d'un module
% peut briser le fonctionnement de ses dépendances.

% Les versions des modules sont lié au publications des module sur les serveurs
% de version tels que que github, gitlab, bitbucket, etc. Une versions est soit
% une branche ou un étiquette. Les versions sont spécifier par un \lstcode{@}
% suivie de la version. Par exemple, la version \lstcode{1.0.0} est notée le
% suffixe \lstcode{@1.0.0}.


Les modules sont hébergés sur des serveurs de version tels que github, gitlab,
bitbucket, etc. Chaque version d'un module est installée dans un répertoire
distinct. Il est donc possible d'avoir plus d'une version d'un module installé
sur le système de fichier.
L'installation des modules s'effectue par l'intermédiaire du module
\lstcode{_git} qui offre une interface à l'utilitaire \lstcode{git}. Le
processus d'installation est séparé en plusieurs étapes.  Le contenu du module
est installé dans un répertoire temporaire qui est ensuite renommé au
répertoire de destination. Cela permet de faire apparaitre le module installé
de façon atomique.

Tout d'abord, la
branche \lstcode{master} du dépôt du module est clonée. Ensuite, une archive de la
version est faite et extraite dans le préfixe des modules. Le préfixe est par
défaut \lstcode{\~\~userlib}.  Il est possible de spécifier un préfixe
d'installation dans lequel installer les modules. Plusieurs versions d'un même
module coexistent dans le même préfixe d'installation.

La branche \lstcode{master} est utilisée comme version de développement et
comme cache pour installer les autres versions. Une version d'un module est soit
un \textit{commit}, une branche ou une étiquette. L'installation d'une version
spécifique utilise la cache pour récupérer l'archive de la version demandée
et l'extraire dans l'espace des modules.

La procédure \lstcode{install} de \lstcode{_pkg} accepte deux paramètres:
le nom du module et de façon optionnelle le préfixe d'installation. Elle
retourne la valeur de vérité vraie (\lstcode{#t}) si l'installation réussit,
sinon elle retourne la valeur de vérité fausse (\lstcode{#f}).
\begin{center}
  \begin{mplisting}{0.4}
(install mod #!optional dir)
\end{mplisting}
\end{center}

L'installation peut être effectuée en passant l'option \lstcode{-install}
à l'interprète Gambit. Cette option requiert le nom du module et
de façon optionnelle le préfixe d'installation.
\begin{center}
  \begin{mplisting}{0.8}
$ gsi -install [-dir <path>] module [...]
\end{mplisting}
\end{center}
Le préfixe \lstcode{<path>} est la racine utilisée pour installer les modules
et est spécifié par l'option \lstcode{-dir}.  La racine par défaut est
\lstcode{\~\~userlib}. Voici un exemple d'installation d'une version spécifique du module
\lstcode{semver} qui implémente la logique du \textit{semantic versioning}.

\begin{center}
  \begin{mplisting}{1}
$ gsi -install -dir /tmp/exemple github.com/frederichamel/semver
\end{mplisting}
\end{center}

\section{Désinstallation}

La désinstallation d'un module consiste à supprimer les fichiers
de ce module. Le module \lstcode{_pkg} offre la procédure
\lstcode{uninstall} qui accepte deux arguments: le nom du module,
et de façon optionnelle, le répertoire dans lequel les modules
sont situés. Les valeurs retournées par cette procédure sont
similaires à la procédure \lstcode{install}.
\begin{center}
  \begin{mplisting}{0.4}
(uninstall mod #!optional dir)
\end{mplisting}
\end{center}
La désinstallation peut être faite en passant l'option \lstcode{-uninstall}
à l'interprète Gambit. Cette option requiert le nom du module et le
répertoire  des modules à désinstaller.
\begin{center}
  \begin{mplisting}{0.8}
$ gsi -uninstall [-dir <path>] module
\end{mplisting}
\end{center}
Le répertoire \lstcode{<path>} est l'emplacement des modules
à désinstaller. Le format des arguments pour la désinstallation
est le même que pour l'installation. Le répertoire par défaut
est le répertoire \lstcode{\~\~userlib}.

La désinstallation du module \lstcode{semver} qui est installé dans
le répertoire \lstcode{/tmp/exemple} est fait par la commande suivante:
\begin{center}
  \begin{mplisting}{1}
$ gsi -uninstall -dir /tmp/exemple github.com/frederichamel/semver
\end{mplisting}
\end{center}


\section{Mise à jour}
Cette opération actualise la branche \lstcode{master} du module.
Cela donne accès aux nouvelles publications d'un module. Pour installer
une nouvelle version d'un module, il suffit de faire la mise à jour
de la branche master et d'installer la nouvelle version.

\begin{center}
  \begin{mplisting}{0.8}
$ gsi -update [-dir <path>] module
\end{mplisting}
\end{center}

\section{Tests unitaires}
Les tests unitaires exécutés sont dans un fichier conjoint au module.
Gambit offre un module de test unitaire nommé \lstcode{_test}. Il
contient plusieurs procédures et macros pour tester le bon fonctionnement d'un module.
Les tests unitaires pour un module nommé \lstcode{A} sont par convention dans le sous-module
\lstcode{A/test}.

\begin{center}
\begin{mplisting}{0.8}
$ gsi module/test
*** all tests passed out of a total of %*\textit{N}* tests
\end{mplisting}
\end{center}

La commande affiche le résultat des tests unitaires contenus dans le
sous-module test.

% Exemple de tests.

\section{Compilation d'un module}
%
La compilation d'un module est faite en passant le nom du module
(\texttt{\textit{<module-ref>}}) en paramètre.  Le compilateur cherche le
module dans les répertoires du \lstcode{##module-search-order}. Le module est
installé au besoin et ensuite compilé dans un sous répertoire. Ce dossier associe
la compilation de ce module à la version de Gambit et à la cible (C, JavaScript, \dots).
La compilation d'un module se fait par la commande suivante:

\begin{center}
\begin{mplisting}{0.8}
$ gsc %*\textit{<module-ref>}*
\end{mplisting}
\end{center}

%% Module avec du C.
L'arborescence du répertoire du module après la compilation du module
\texttt{\_digest} pour le \textit{backend} C est:
%
\begin{center}
\begin{mplisting}{0.8}
|-- _digest@gambit409003@C
|   |-- _digest.c
|   \-- _digest.o1
|-- _digest#.scm
|-- _digest.scm
\-- test.scm
\end{mplisting}
\end{center}


\section{Comparaison avec d'autres systèmes}

L'organisation des modules sur le système de fichier dans Gambit
diffère de celui de OCaml, Python et NodeJS. Ceux-ci ne permettent pas
l'installation de plus d'une version d'un module directement. Le système
de module qui est utilisé dans le langage de programmation Go est le plus
similaire à celui dans Gambit.

Un système de module permet la coexistence de plusieurs versions du même module
sur le système de fichier s'ils sont considérés comme des modules différents.
L'installation d'une version différente d'un module ne remplace pas la version
déjà installée. L'organisation des bibliothèques est importante pour permettre
cette coexistence.

La caractéristique que le système de bibliothèque doit avoir pour permettre
plusieurs versions d'une bibliothèque est une organisation qui permet de
distinguer les différentes versions de la bibliothèque par un chemin unique.
La plupart des systèmes de module ne distinguent pas les versions d'un même
module et ne permettent l'installation que d'une seule version. Les systèmes de
module permettent la gestion de différents préfixes dans lesquels les modules sont
installés. Chaque préfixe peut contenir une version différente d'un même
module. Pour avoir une nouvelle version d'un module, il faut créer un nouveau
préfixe.


%Le nombre de bibliothèque moyen dans un langage est d'environ 90000 \colorbox{red}{ref}
%en prennant en compte les gestionnaire de modules (bibliothèques) suivant:

% \todo{Include number of module in pm from www.modulecounts.com}

% Il est à noté que le nombre de bibliothèques qu'un langage possède est lié au nombre
% d'utilisateur. Aussi le nombre de bibliothèques n'est pas représentatif du nombre
% réellement utilisé.

\begin{figure}[h]
\begin{tabular}{|r|c|c|c|c|}
  \hline   & Multiple versions \\\hline
  OCaml    & \xmark            \\\hline
  Python   & \xmark            \\\hline
  NodeJS   & \xmark            \\\hline
  Java     & \xmark            \\\hline
  Go       & \checkmark        \\\hline
%  Gambit Scheme & \checkmark & \checkmark & default \\\hline
\end{tabular}

\caption{Une table qui compare différents systèmes de module sur la capacité
  d'installer plusieurs versions d'un module.  Le système Go permet plusieurs
  versions d'un module pour des versions incompatibles selon le sémantique de
  version. La version \texttt{1.0.0} coexiste avec la version \texttt{2.0.0}.
  La version récente \texttt{1.2.0} remplace la vieille version \texttt{1.0.1}.}

\end{figure}




%\subsubsection{Organisation dans Gambit Scheme}
%\todo{}
% exemple coexistence sur un système de fichier

\subsection{Organisation de OCaml}
%
Le système de gestion de bibliothèques d'OCaml se nomme OPAM. Ce système permet
d'avoir plusieurs environnements distincts contenant chacun un ensemble de
versions des bibliothèques.  Chaque environnement permet l'installation d'une
version spécifique de chaque bibliothèque et est étiqueté avec un nom choisi
par l'utilisateur. Un changement d'environnement est effectué par une requête
de l'utilisateur \verb|opam switch <envname>|. Il utilise le projet
\textit{mancoosi} pour gérer les contraintes de
version, les dépendances optionnelles et la gestion des conflits.
L'environnement par défaut est lié aux dépôts standard d'OCaml.

\subsection{Organisation de Python}
%
L'organisation des bibliothèques Python ne permet de stocker qu'un (typiquement la dernière)
version d'une bibliothèque. Les emplacements des bibliothèques sont modifiés
par la variable d'environnement \verb|PYTHONPATH| qui correspond dans Python à
la variable \verb|path| de la bibliothèque interne \verb|sys|. Le système de
bibliothèque de Python ne permet pas la coexistence de plusieurs versions de la
même bibliothèque. Le \textit{package manager} principal de Python est
\textit{pip}.  L'installation d'une autre version d'une bibliothèque
désinstalle ou masque la version déjà installée. Le système de module ne permet
pas de référer à deux versions de la même bibliothèque.

\begin{figure}[ht]
    \begin{minipage}[t]{0.5\textwidth}
\begin{verbatim}
>>> import sys
>>> print('\n'.join(sys.path))
/usr/lib/python37.zip
/usr/lib/python3.7
/usr/lib/python3.7/lib-dynload
/home/username/.local/lib/python3.7/site-packages
/usr/lib/python3.7/site-packages
\end{verbatim}
    \end{minipage}
    \caption{L'ensemble des répertoires qui est utilisé par Python version 3.7
    pour organiser les bibliothèques sur un système de type Linux.}
\end{figure}

Python a le concept équivalent à OCaml de \texttt{virtualenv} qui permet
d'avoir plusieurs versions installées sur la même machine. Cela permet
d'installer des bibliothèques dans un environnement isolé des autres.
L'avantage est qu'il est possible d'avoir une compatibilité avec des logiciels
qui utilisent des versions de bibliothèques antérieures. Un inconvénient est
qu'il n'y a pas un partage des versions de bibliothèques communes entre les
différents environnements, cela a comme effet d'avoir plus d'un exemplaire d'une
version de la bibliothèque installée sur le système de fichier. Chaque
\texttt{virtualenv} ne permet qu'une seule version de chaque bibliothèque
d'être installé.

%\todo{\hspace{2.5in}Image de coexistence venv}

\subsection{Organisation de NodeJS}
%
NodeJS est un interprète JavaScript qui a été conçu pour être exécuté du côté
serveur dans un modèle client-serveur. Les bibliothèques sont installées au
niveau du projet. Cela implique que plusieurs projets qui utilisent la même
version de la bibliothèque vont référer au même exemplaire de la
bibliothèque.

La structure d'une bibliothèque dans NodeJS est décrite par un fichier
\texttt{package.json} qui contient plusieurs méta données comme
le nom, la version, le nom des dépendances, la version des dépendances,
la licence sous laquelle la bibliothèque est publiée et plusieurs autres
méta données liées à la bibliothèque. Sous NodeJS, les bibliothèques sont gérées
par projet plutôt que globalement cela a comme avantage que chaque projet
fonctionne avec ses versions des bibliothèques.

\subsection{Organisation de Java}
%
Les modules en Java sont nommés \textit{package}.  Le nom des modules utilise
généralement l'inverse d'une URL comme espace de nom. Par exemple, les noms des
modules liés aux services Google vont débuter par \texttt{com.google}. Cette
convention a pour but d'unifier les noms de module. La version des modules
n'est pas liée au nom du module dans le cas de Java. Il n'est pas possible de
charger deux modules qui utilisent le même espace de nom, comme deux versions
d'un même module.

\subsection{Organisation de Go}
%
L'organisation des bibliothèques dans Go~\cite{GoLang} est plus dans un contexte
environnement dont la racine est spécifiée par la variable d'environnement
\texttt{GOPATH} avec un répertoire pour les exécutables compilés
(\texttt{bin}), un répertoire contenant le code source des différents projets
(\texttt{src}) et un répertoire pour les objets des modules installés
(\texttt{pkg}). Chaque paire de systèmes d'exploitation et d'architecture a son
propre répertoire dans \texttt{pkg}.

Le système Go permet l'installation de plusieurs versions d'un même module dans
le même environnement en utilisant le service \textit{gopkg.in}. Il y a deux
syntaxes utilisées pour l'URL des modules Go avec \textit{gopkg.in}. Il est possible
de spécifier une version spécifique du module lors de l'importation.

\noindent
\begin{figure}[ht]
  \centering
\begin{mplisting}{1}
gopkg.in/pkg.v3      -> github.com/go-pkg/pkg (branch/tag v3, v3.N, or v3.N.M)
gopkg.in/user/pkg.v3 -> github.com/user/pkg   (branch/tag v3, v3.N, or v3.N.M)
\end{mplisting}
  \caption{Exemple d'importation de la version v3 du module pkg en utilisant
    le service \textit{gopkg.in}.}
  \label{fig:gopkg_import}
\end{figure}

\begin{figure}[h]
  \lstset{language={Go},frame=single}
\begin{mplisting}{1}
package main

import (
  hellov1 "gopkg.in/FredericHamel/go-hello.v1"
  hellov2 "gopkg.in/FredericHamel/go-hello.v2"
)

func main() {
  // use hello version 1
  hellov1.Hello("Bob")

  // use hello version 2
  hellov2.Salut("Alice")

  // hellov1.Salut("Eve")
}
\end{mplisting}
  \caption{Un exemple qui montre l'importation de deux versions d'un même module
    en Go. Le module \textbf{go-hello} version 2 exporte la fonction \texttt{Salut}
    qui n'existe pas dans la version \texttt{1}.}
\end{figure}

% https://labix.org/gopkg.in
% go help importpath

%La structure du répertoire dans un projet g
\begin{figure}[ht]
  \centering
  \lstset{frame=single}
\begin{mplisting}{1}
$GOPATH/
  - bin
    - ... binaries
  - src
    - github.com
      - UserName1
        - project1
        - project2
      - UserName2
        - projectA
        - projectB
  - pkg
    - linux_amd64
      - pkglist
        - objets
\end{mplisting}
  \caption{Arborescence des fichier dans le gopath.}
  \label{fig:organisation_go}
\end{figure}

\section{Conclusion}
%
Ce chapitre a traité de la gestion des modules.  Les opérations du système de
modules présentés dans ce chapitre sont l'installation, la désinstallation et
la mise à jour.  Notre approche de gestion des modules offre correctement la
possibilité d'avoir plus d'une version d'un module. Cela empêche les bris de
dépendances lors de l'installation de nouveaux modules.  L'installation des
modules peut-être déclenchés procéduralement ce qui est nécessaire pour diffuser
les modules.

Il est possible de forcer la compilation d'un module par la présence d'un fichier
\textit{module-name.\_must-build\_}. Cette fonctionnalité permet le chargement d'un
module qui doit être compilé pour fonctionner.


