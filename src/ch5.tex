
\chapter{Gestion des modules}
\label{ch:module_management}
% Installation, Désinstallation, Mise à jour, Compilation/Exécution
La gestion des modules inclus généralement l'installation, la mise à jour et
la désinstallation. L'organisation des modules est un élément important
dans la gestion des modules. Les gestionnaires de modules sont présent dans
beaucoup de langage telle que Python, Ruby, Javascript, Common Lisp, Go, etc.
Un gestionnaire de module est inclus dans le système Gambit Scheme pour
organiser les modules.

Le gestionnaire de module de Gambit Scheme fournit les opérations
d'installation, de désinstallation, de mise à jour, de compilation
d'un module et l'exécution des tests unitaires du module. Les modules
sont versionnés par Git. L'emplacement des modules est spécifié par
une liste de répertoires qui inclus les modules systèmes et les modules
utilisateurs. La gestion des modules est effectuée par le module \lstcode{_pkg}
qui offre les procédure d'installation d'installation et de désinstallation.


% % quicklisp.org
% Les gestionnaires de module permettent plusieurs opérations sur les modules
% comme l'installation, la mise à jour et la désinstallation. La gestion inclut
% l'organisation des versions des modules sur le système de fichier. Beaucoup de
% de langages ont au moins un gestionnaire de modules. Le langage Python a le
% gestionnaire de module \textbf{pip}. L'implémentation NodeJS pour Javascript à
% le gestionnaire de module \textbf{npm}. Le langage Common Lisp a le gestionnaire
% \textit{quicklisp}.

% Les gestionnaires de module utilisent une hiérarchie de répertoires pour
% organiser les modules. Il existe plusieurs façon pour gérer les modules.
% Certain permette plusieurs versions d'un module dans un même environnement,
% comme dans le langage Go.

% Les module Gambit sont situés dans des répertoires spécifié dans le
% \lstcode{search-order}. Par défaut, il y a un répertoire pour les modules
% systèmes\ref{modules_systems} et un répertoire pour les modules
% utilisateurs\ref{modules_utilisateurs}. Ces répertoires sont associés au
% répertoire d'installation de Gambit. Les répertoires d'installation sont
% dénotés par un préfixe \lstcode{\~\~}.  Le modules système utilise utilise par
% défaut le répertoire d'installation \lstcode{\~\~lib} alors que les modules
% utilisateurs utilise le répertoire \lstcode{\~\~userlib}. Chaque module peut
% être installé, désinstallé, testé et compilé. La plupart de ces opérations est
% faite par le module gambit \lstcode{_pkg}.  Il est possible d'invoquer ces
% opérations par des arguments de ligne de commande passé à Gambit.

\section{Organisation des modules}

Les modules sont organisés dans des répertoires données par le système Gambit.
Ils contiennent l'ensemble des modules internes et actuellement installés sur
le système. Il y a trois principaux répertoires spéciaux qui contiennent des
modules.

\begin{itemize}
  \item \lstcode{\~\~userlib}: c'est le répertoire qui contient les modules
    de l'utilisateur courant.

  \item \lstcode{\~\~lib}: c'est le répertoire d'installation de Gambit
    qui contient les modules système. Les modules dans ce répertoire sont
    commun à tous les utilisateurs.

  \item \lstcode{\~\~instlib}: c'est le répertoire d'installation des modules.
    Par défaut, il correspond au répertoire \lstcode{\~\~userlib}.
\end{itemize}

Un module local ou hébergé est identifié de façon unique par un
\lstcode{module-ref}.  Un \lstcode{module-ref} est séparé en trois parties: le
\lstcode{hostname}, le \lstcode{path} et l'étiquette qui donne la version.  La
différence entre une référence à un module local et hébergé est la première
partie. Dans le cas hébergé, le champs \lstcode{hostname} contient
l'information du nom de domaine qui, dans le cas local, est vide.
Le \lstcode{<tag>} spécifie la version du module avec une référence à
un commit du système de révision Git. Un \lstcode{<tag>} vide réfère
à la version de développement du module.  La syntaxe du
nom de domaine est donnée par la grammaire[\ref{lst:hostname->grammar}].  La
grammaire formelle\ref{lst:module-ref->grammar} décrit la syntaxe du
\lstcode{<module-ref>} dans le cas hébergé et local.

\begin{center}
  \lstset{caption={Grammaire formelle},captionpos=b,frame=single}
  \begin{mplisting}{0.8}
<module-ref> := <local> | <hosted>
<local>      := <id>(/<id>)*<tag>
<hosted>     := <hostname>/<id>/<id>(/<id>)*(@<tag>)?
\end{mplisting}
  \label{lst:module-ref->grammar}
\end{center}

Le \lstcode{module-ref} \lstcode{github.com/gambit/hello} réfère
au module \lstcode{hello} sur le serveur de révision \lstcode{github.com}
dans l'espace \lstcode{gambit}. Le champs \lstcode{host} de est dans ce
cas \lstcode{github.com/gambit} qui correspond au nom de domaine avec
le nom de l'espace sur le le serveur.

% \begin{itemize}
%   \item \lstcode{install} effectue l'installation de modules.
%   \item \lstcode{update} effectue la mise à jour de la cache des modules demandés. Cela
%     permet d'actualiser les nouvelles versions disponible d'un module.
%   \item \lstcode{uninstall} désinstalle les modules spécifié.
%   \item \lstcode{test} exécute les tests unitaires des modules spécifiés.
% \end{itemize}

\subsection{Installation de module}

L'installation des modules peut être soit à partir d'un serveur de révision
ou d'un répertoire local versionné par git. Dans les deux cas d'installation,
le \lstcode{module-ref}  est utilisé pour déterminer l'emplacement du module
dans le répertoire des modules. Chaque \lstcode{module-ref} est associé à un
réperoire unique dans le répertoire des modules.




% Les modules qui sont hébergés sur un serveur de révision comme github, gitlab, bitbucket,
% etc ont un \lstcode{module-ref} distinct.

% L'organisation des module doit permettre l'installation de plusieurs
% version d'un même module. C'est pour cela qu'il sont organisés dans une
% hiérarchie de répertoire lié au \lstcode{module-ref} du module.
% Chaque version d'un module est identifié par un seul \lstcode{module-ref}
% qui est associé à un seul emplacement sur le système de fichier.

% L'organisation des répertoires des modules permet l'installation de plusieurs
% versions d'un même module. Cela garantie que tous les modules qui utilise une
% version antérieur de modules fonctionne toujours. Certains systèmes de module
% ne conserve qu'une seul version de chaque module. La mise à jour d'un module
% peut briser le fonctionnement de ses dépendances.

% Les versions des modules sont lié au publications des module sur les serveurs
% de version tels que que github, gitlab, bitbucket, etc. Une versions est soit
% une branche ou un étiquette. Les versions sont spécifier par un \lstcode{@}
% suivie de la version. Par exemple, la version \lstcode{1.0.0} est notée le
% suffixe \lstcode{@1.0.0}.

% TODO: test if branch work


Les modules sont hébergés sur des serveurs de version tel que github, gitlab,
bitbucket, etc. Chaque version d'un module est installé dans un répertoire
distinct. Il est donc possible d'avoir plus d'une version d'un module installé.
L'installation des modules s'effectue par l'intermédiaire de
\lstcode{git}. Le processus d'installation est séparé en plusieurs étapes.  Le
contenu du module est installé dans un répertoire temporaire qui est ensuite
renommé au répertoire de destination. Cela permet d'installer le module de
façon atomique.

Tout d'abord, la
branche \lstcode{master} dépôt du module est cloné. Ensuite un archive de la
version est faite et extraite dans le préfixe des modules. Le préfixe est par
défaut \lstcode{\~\~userlib}.  Il est possible de spécifier un préfixe
d'installation dans lequel installer les modules. Plusieurs versions d'un même
module coexistent dans le même préfixe d'installation.

La branche \lstcode{master} est utilisé comme version de développement et
comme cache pour installer les autres versions. Une version d'un module est soit
un commit une branche ou un étiquette. L'installation d'une version
spécifique utilise la cache pour récupérer l'archive de la version demandé
et l'extraire dans l'espace des module.

La procédure \lstcode{install} de \lstcode{_pkg} accepte deux paramètres:
le nom du module et de façon optionnelle le préfixe d'installation. Elle
retourne la valeur de vérité vrai (\lstcode{#t}) si l'installation réussi,
sinon faux (\lstcode{#f}).
\begin{center}
  \begin{mplisting}{0.4}
(install mod #!optional to)
\end{mplisting}
\end{center}

L'installation peut être effectué en passant l'option \lstcode{-install}
à l'interprète gambit. Cette option requière le nom du module et
de façon optionnelle le préfixe d'installation.
\begin{center}
  \begin{mplisting}{0.8}
> gsi -install [-to <path>] module [...]
\end{mplisting}
\end{center}
Le préfixe \lstcode{<path>} est la racine utilisée pour installer les modules
et est spécifier par l'option \lstcode{-to}.  La racine par défaut est
\lstcode{\~\~userlib}. Voici un exemple d'installation d'une version spécifique du module
\lstcode{semver} qui implémente la logique du \textit{semantic versioning}.

\begin{center}
  \begin{mplisting}{1}
> gsi -install -to /tmp/exemple github.com/frederichamel/semver/tree/1.0.1
\end{mplisting}
\end{center}

\section{Désinstallation}

La désinstallation d'un module consiste à supprimer les fichier
de ce module. Le module \lstcode{gambit/pkg} offre la procédure
\lstcode{uninsall} qui accepte deux arguments: le nom du module
et de façon optionnelle le répertoire dans lequel les modules
sont situé. Les valeurs retournées par cette procédure sont
similaire à la procédure.
\begin{center}
  \begin{mplisting}{0.4}
(uninstall mod #!optional to)
\end{mplisting}
\end{center}
La désinstallation peut être fait en passant l'option \lstcode{-uninstall}
à l'interprète Gambit. Cette option requière le nom du module et le
répertoire  des module à désinstaller.
\begin{center}
  \begin{mplisting}{0.8}
> gsi -uninstall [-to <path>] module
\end{mplisting}
\end{center}
Le répertoire \lstcode{<path>} est l'emplacement des module
à désinstallé. Le format des arguments pour la désinstallation
est le même que pour l'installation. Le répertoire par défaut
est le répertoire \lstcode{\~\~userlib}.

La désinstallation du module \lstcode{semver} dans installé dans le
répertoire \lstcode{/tmp/exemple} est fait par la commande suivante:
\begin{center}
  \begin{mplisting}{1}
> gsi -uninstall -to /tmp/exemple github.com/frederichamel/semver/tree/1.0.1
\end{mplisting}
\end{center}


\section{Mise à jour}
Cette opération actualise la branche \lstcode{master} du module.
Cela donne accès au nouvelle publication d'un module. Pour installer
une nouvelle version d'un module, il suffit de faire la mise à jour
de la branche master et d'installer la nouvelle version.

\begin{center}
  \begin{mplisting}{0.8}
> gsi -update [-to <path>] module
\end{mplisting}
\end{center}

\section{Tests unitaires}
Les tests unitaires exécutés sont dans dans un fichier conjoint au module.
Gambit offre un module de test unitaire nommé \lstcode{gambit/test}. Il
contient plusieurs procédure pour tester le bon fonctionnement d'un module.
Les tests unitaires pour un module nommé \lstcode{A} est un fichier
\lstcode{A-test.scm} dans le répertoire du module.

\begin{center}
  \begin{mplisting}{0.8}
> gsi -test [-to <path>] module
\end{mplisting}
\end{center}

La commande de test ci-dessus réussi si l'exécution des teste termine sans
lancer d'erreurs.

% Exemple de tests.

\section{Compilation d'un module}
Il n'y a pas d'options spécial pour demander la compilation d'un module.
Il suffit d'invoquer le compilateur de Gambit avec le nom du module
à compiler. Le nom du module est le même que celui utilisé dans la
l'importation.

%% Module avec du C.


\section{Comparaison avec d'autre système}

TODO: not done

