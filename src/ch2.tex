
\chapter{Bibliothèque Scheme}

Le langage Scheme\cite{Scheme} à été conçu en 1975 par Guy L. Steele et Gerald
Jay Sussman.  C'est un langage de programmation avec un système de type
dynamique, cela signifie que les variables peuvent contenir n'importe quels
types. Il supporte plusieurs paradigmes de programmation comme fonctionnelle,
impérative et méta. Chaque expression est représenté sous forme préfixé et
fortement parenthésé.  Un programme Scheme est une séquence de liste parenthésé
en forme préfixé, ce sont des \textit{s-expresssions}.  Chaque
\textit{s-expression} correspond soit à une constante, une application de
procédure ou une application de macro. Les macros sont lié au paradigme de
méta programmation qui manipulent les expressions.

Les formes de base usuelles en Scheme sont \lstcode{define}, \lstcode{lambda},
\lstcode{let}, \lstcode{if} and \lstcode{set!}.
\begin{itemize}
  \item La forme \lstcode{(define <name> <val>)} associe le nom \lstcode{<name>} avec
    la valeur \lstcode{<val>}. Il est utilisé pour définir des variables globales.

  \item La forme \lstcode{(lambda <args> <body>)} permet la définition de
    procédures anonymes. Les arguments sont \lstcode{<args>} et le corps
    de procédure \lstcode{<body>}.

  \item La forme \lstcode{(let <bindings> <body>)} permet de créer des
    associations (\lstcode{<bindings}) visible seulement dans le contexte de
    \lstcode{<body>}. Les associations sont sous la forme d'une liste
    associative nom et valeur.

  %% XXX: Too much???
  \item Les conditions sont géré par la forme \lstcode{(if <e1> <e2> <e3>)}.
    La branche \lstcode{<e1>} est exécutée si la condition \lstcode{<e2>} est
    vrai sinon \lstcode{<e3>}.

  \item La forme \lstcode{(set! <name> <val>)} modifie le contenu de la variable
    \lstcode{<name>} avec la valeur \lstcode{<val>}.
\end{itemize}

%read from here

La méta programmation est un paradigme lié à l'utilisation de macro qui sont
des entités qui manipulent la structure du programme. Elle est utilisé pour
ajouter des abréviations dans le langage qui simplifie l'écriture du code.  La
section \ref{sec:proc_and_macro} détaille de la méta programmation en Scheme.

Les expressions Scheme sont en forme préfixe. Cela signifie que l'opération
précède les opérandes. Cette forme est plus utilisé dans les langage de la famille
LISP.

% Une expression peut être organisé de plusieurs façons, infixe, préfixe ou
% suffixe.  La différence entre ces organisations est l'emplacement de
% l'opération et des opérandes dans l'expression.  Une expression en syntaxe
% infixe place l'opération entre les opérandes.  Cette forme est souvent utilisé
% dans les langages impératif. La forme préfixe commence par l'opérateur suivie
% des opérandes. Cette forme est plus utilisé dans les langages de la famille
% LISP.  La forme suffixe place les opérations après les opérandes.  Le tableau
% \ref{tab:prefix_vs_infix} donne des exemples d'expression préfixe avec
% l'équivalent infixes.


% \begin{verbatim}
% - Scheme
%    - Langage dynamique
%   - Supporte plusieurs paradigmes:
%     - fonctionnel
%     - impérative
%     - méta (programmation de macro)
%   - Préfixé / ~Infixe
%   - S-expression
% \end{verbatim}


\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|l|}
  \hline
  \textbf{Préfixe}& \textbf{Infixe}& \textbf{Suffixe}\\\hline
  \begin{mplisting}{0.1}
(+ 1 2)
\end{mplisting}&
  \begin{mplisting}{0.1}
1 + 2;
\end{mplisting}&
  \begin{mplisting}{0.1}
1 2 +
\end{mplisting}\\
\hline
  \begin{mplisting}{0.22}
(proc a1 a2 a3)
\end{mplisting}&
  \begin{mplisting}{0.22}
proc(a1, a2, a3);
\end{mplisting}&
  \begin{mplisting}{0.22}
a1 a2 a3 proc
\end{mplisting}\\
\hline
%    \begin{mplisting}{0.25}
%(if e1
%    e2
%    e3)
%\end{mplisting}&
%    \begin{mplisting}{0.25}
%if(e1)
%  e2;
%else
%  e3;
%\end{mplisting}\\
%\hline
\end{tabular}
\end{center}
  \caption{Voici des example qui montre une comparaison entre une syntaxe préfixe, infixe et suffixe.}
  \label{tab:prefix_vs_infix}
\end{table}

% La définition des associations globales en Scheme est effectuée avec \lstcode{define}.

Les différents types que les valeurs peuvent prendre sont Les types de donnée
disponible en Scheme sont \lstcode{boolean}, \lstcode{pair}, \lstcode{symbol},
\lstcode{number}, \lstcode{char}, \lstcode{string}, \lstcode{vector},
\lstcode{port} et \lstcode{procedure}.

\section{Procédure et Macro}
\label{sec:proc_and_macro}

Les procédures sont des objets de premier classe, cela signifie qu'elles
peuvent être manipulée comme n'importe quels types de donnée. Elles peuvent
être passées en tant que paramètre à une procédure et retourné en tant que
résultat.  Certaines fonctions -- telles que \lstcode{map}, \lstcode{fold}, etc.
-- bénéficie que les procédures sont des objets de premier classe.

Les procédures et les fonctions sont définis par le constructeur
\lstcode{lambda} qui prend une liste d'arguments et une séquence d'au moins une
\textit{s-expression} comme corps. Lors de l'application d'une procédure chacun
des arguments est évalué puis passés à la procédure. C'est un mode de passage
de paramètre par valeur. Il n'y a de forme spéciale pour les boucle, car elle
peuvent construite par la récursion. Le langage offre une récursion sans coût
avec l'appel terminal.  Il est possible d'ajouté une syntaxe pour les boucle en
utilisant la méta programmation.
% forme spéciale pour les boucle -> Les boucles sont faite par la récursion


% \begin{figure}[ht]
%   \begin{center}
%     \begin{tabular}{|l|}
%       \hline
%     \begin{mplisting}{0.55}
% (define fact
%   (lambda (n) (if (= n 0) 1
%                   (* n (fact (- n 1))))))
% \end{mplisting}\\\hline
%     \end{tabular}
%   \end{center}
%   \label{fig:fact1}
%   \caption{Voici une implémentation de la fonction factoriel en Scheme.
%   Cela montre un exemple de récursion.}
% \end{figure}

% READ Distinguer macro procedure.
% \begin{figure}[ht]
%   \begin{center}
%     \begin{tabular}{|l|}
%       \hline
%     \begin{mplisting}{0.65}
% (define map
%   (lambda (f lst)
%     (if (pair? lst)
%         (cons (f (car lst)) (map f (cdr lst)))
%         lst)))
% \end{mplisting}\\\hline
%     \end{tabular}
%   \end{center}
%   \label{fig:fact1}
%   \caption{Voici une implémentation de la fonction d'ordre supérieur \lstcode{map} en Scheme.
%   Cela montre un exemple utilise les procédure en objets de première classe et
%   aussi un exemple d'application récursive.}
% \end{figure}



% La récursion est la façon dont les boucle sont faites.
La programmation méta est présente dans plusieurs langage comme C, C++, LISP,
Haskell, Scheme, etc. Elle est basé sur la capacité d'un programme de manipuler
d'autre programme comme des données. Cela implique qu'il est possible de
générer, analyser et modifier le code d'un autre programme s'incluant.  Les
constructions utilisées pour manipuler le code du programme et
ajouter des extensions au langage sont les macros.

En C et C++, les macros ne permettent pas de récursion se référant à elle-même.
Ils sont basés sur un modèle de remplacement textuel simple. Un appel à la
macro est remplacer par le corps de celle-ci. Les macros de style LISP ont
accès à l'ensemble des procédure, ce qui leurs donne plus de flexibilité.  La
différence entre les procédures et les macros est le mode de passage de
paramètres.  Les paramètres sont passés à la macro sans être évalués, c'est ce
qu'on appelle le passage par nom.  Certain Scheme offre la forme
\lstcode{define-macro} pour définir les macros.  Cette forme est équivalente au
\lstcode{defmacro} de LISP. Elle accepte en entré des \textit{s-expression}s et
retourne une \textit{s-expression} (soit une liste ou une constante).  Le
problème de cette forme spéciale est l'hygiène qui est traité dans le chapitre
\ref{XXX}.

\begin{figure}[htbp]
  \begin{tabular}{|l|}\hline
\begin{mplisting}{0.7}
(define-macro (include filename)
  (call-with-input-file
    filename
    (lambda (port)
      `(begin
        ,@(read-all port)))))
\end{mplisting}\\\hline
\end{tabular}

  \caption{Implémentation de la macro \texttt{include} qui permet l'inclusion
  d'un fichier dans un autre fichier avec la syntax \texttt{define-macro}.}

  \label{fig:macro_include}
\end{figure}

Un exemple qui montre les capacité des macros Scheme est la macro
\lstcode{include}.  Cette macro permet l'inclusion du contenu d'un fichier au
point d'application.  Pour inclure un fichier dans un autre, il faut tout
d'abord lire le contenu du fichier à inclure. Ensuite, il suffit de retourné le
code lu. La figure \ref{fig:macro_include} montre une implémentation de cette
macro avec \lstcode{define-macro}.  Pour les implémentation de Scheme ne
supportant pas la forme \lstcode{define-macro}, il est possible d'implémenter
la forme \lstcode{include} avec \lstcode{define-syntax} qui est l'alternative à
\lstcode{define-macro}. L'implémentation de cette macro est donnée à la figure
\ref{fig:macro_include_def_syntax}. Les particularité de
\lstcode{define-syntax} ne sont pas mentionnées dans ce mémoire.

% --------------------------------------MOVE--------------------------------------

% Certaines implémentations de Scheme n'ont pas la forme
% \lstcode{define-macro}. Il est possible d'écrire la macro
% \lstcode{include} en utilisant la \lstcode{define-syntax}
% et \lstcode{syntax-case} qui fait partie du standard R5RS
% \cite{Scheme:R5RS}. La figure \ref{fig:macro_include_def_syntax}
% montre implémentation possible de cette macro.

\begin{figure}[ht]
\begin{tabular}{|l|}\hline
\begin{mplisting}{0.8}
(define-syntax include
  (lambda (stx)
    (define (read-all port)
      (let loop ((rev-lst '()))
        (let ((expr (read port)))
          (if (eof-object? expr)
            (reverse rev-lst)
            (loop (cons expr rev-lst))))))
    (syntax-case stx ()
      ((_ fn)
       (let ((filename (syntax->datum (syntax fn))))
         (let ((content
                 (call-with-input-file
                    filename
                    (lambda (port)
                      (cons 'begin (read-all port))))))
           (datum->syntax stx content)))))))
\end{mplisting}\\\hline

\end{tabular}
   \caption{Implémentation de la macro \texttt{include} qui permet l'inclusion
   d'un fichier dans un autre fichier avec la syntaxe \texttt{define-syntax}.
   Cette macro effectue la même action que celle définit dans la figure
   \ref{fig:macro_include}.}

   \label{fig:macro_include_def_syntax}
\end{figure}

\section{Structure des Bibliothèques}

Les bibliothèques, aussi appelées modules, facilitent le partage de
fonctionnalités entre plusieurs programmes. Dans le standard
R4RS\cite{Scheme:R4RS} et R5RS\cite{Scheme:R5RS} les modules consistent en des
fichiers Scheme qui contiennent des définitions de procédures et de macros. Il
sont chargés dans le module courant par la procédure \lstcode{load}. Certaines
implémentations de Scheme ont la forme spéciale \lstcode{include} qui permet de
séparer un module Scheme en plusieurs parties. Cette forme peut s'ajouter
facilement au langage (voir la figure \ref{fig:macro_include_def_syntax}).  Le
modèle de bibliothèque de la 4e et 5e révision de Scheme possède plusieurs
lacunes.

%% Gambit doc
\begin{itemize}
  \item Ce modèle de chargement n'est pas à l'abri des chargements multiples
    d'un module qui mène soit à de la duplication de code (dans le cas de \lstcode{include})
    ou à de la réévaluation d'un code (dans le cas de \lstcode{load}).

  \item Toutes les déclarations dans un module sont ajoutés à l'environnement
    global lors du chargement par \lstcode{load}. Cela mène à des conflits de
    nom entre les identifiants du module principal et des modules importés.

  \item L'importation d'un module par \lstcode{load} ou \lstcode{include} nécessite la connaissance
    de son emplacement dans le système de fichier. L'emplacement spécifier est soit relatif ou
    absolu.

\end{itemize}

% \begin{verbatim}
% +-----------------------------------+
% | - Analyse lexicale                |
% | - Analyse syntaxique              |
% | - Expansion macro                 |
% | - Evaluation                      |
% +-----------------------------------+
% \end{verbatim}

Le chargement d'un module dans Gambit Scheme par \lstcode{load} se fait en plusieurs
phases: l'analyse lexicale, l'analyse syntaxique, l'expansion de macro et
l'évaluation. L'analyse lexicale brise l'expression en mots. La séquence de
mots est associée à un contexte par l'analyse syntaxique dans laquelle il y a aussi
une expansion des macros. Le \lstcode{include} d'un fichier n'effectue qu'un
analyse lexicale qui est effectué par la procédure \lstcode{read}. L'évaluation
est effectué après l'analyse syntaxique et l'expansion des macros. D'autres systèmes
Scheme permettent le chargement des macros par \lstcode{load}.

Dans un module, il y a du code qui est exécuté lors de l'expansion (les macros)
et à l'évaluation. La procédure \lstcode{load} donne accès au procédure définit
dans le module, mais pas aux macros, car elles sont expansées.  Après un
\lstcode{load}, il ne reste que les procédures et variables globales qui
résultent de l'expansion des macros.  Pour avoir accès aux macros, il faut
utiliser la forme spécial \lstcode{include} qui est expansé par le contenu du
fichier.  L'expression \lstcode{(include "foo#.scm")} est remplacé par le
contenu du fichier \lstcode{foo#.scm}. L'exemple \ref{fig:r4rs_fact} montre un
exemple de module simple n'utilisant que \lstcode{load}.

\begin{figure}[ht]
  \begin{center}
    \begin{tabular}{|l|l|}
    \hline
    \begin{mplisting}{0.4}
;; fact.scm
(define (fact n)
  (if (< n 2)
    n
    (* n (fact (- n 1)))))
\end{mplisting} &
    \begin{mplisting}{0.4}
;; main.scm
(load "fact.scm")
(display (fact 5))
\end{mplisting} \\\hline
    \end{tabular}
  \end{center}

  \caption{Le fichier \texttt{fact.scm} est un exemple de module R4RS exposant
  la fonction mathématique \lstcode{fact}. Le fichier \texttt{main.scm} est un
  programme principal qui utilise le module \texttt{fact.scm}.}
  \label{fig:r4rs_fact}
\end{figure}


% - Structure global
% - Nom module
% - Export
% - Import
% - Corps de module

Le standard R6RS\cite{Scheme:R6RS} renforce le concept de modules avec la
syntaxe \lstcode{library}.  Un module R6RS est séparé en 4 parties: le nom, une
sous forme \lstcode{export}, une sous forme \lstcode{import} et le corps du
module. Le nom du module l'identifie de façon unique, il peut contenir une
spécification de version. La version est spécifié par une liste d'entiers
positifs. Une liste vide \lstcode{()} est l'équivalent de ne pas spécifier la
version. Ensuite, il y a la liste des exportation spécifier par la sous forme
\lstcode{export}. Chaque élément de cette liste est soit un identifiant ou un
une sous forme \lstcode{rename} qui renomme l'identifiant exporté. Le
\lstcode{import}, donne la liste des dépendances du module. Chaque dépendance
spécifie:

\begin{itemize}
  \item le nom du module importé et de façon optionnelle une contrainte sur
    la version;
  \item le niveau d'import (temps d'expansion ou évaluation);
  \item un sous ensemble du \lstcode{export} du module et le nom local
    utilisé au sein du module courant pour chaque exportation du module.
\end{itemize}

Le corps du module contient une séquence de définitions suivit par une séquence
d'expressions. Une définition peut être soit local ou exportée. Les expressions
initialisent le module lors de l'exécution.  Le R6RS ajoute aussi la forme
\lstcode{import} pour l'importation d'un module et enlève la procédure
\lstcode{load}.  Contrairement au \lstcode{load}, la forme \lstcode{import}
empêche le chargement multiple d'un module.  La syntaxe du \lstcode{import}
permet de manipuler les noms des symboles importés et exportés.\\
\begin{center}
  \lstset{language={scheme},
          captionpos=b,
          caption={Structure globale d'un module R6RS}}
  \begin{mplisting}{0.5}
(library <library name>
  (export <export spec> ...)
  (import <import spec> ...)
  <library body>)
\end{mplisting}
\end{center}

La forme \lstcode{import} de R6RS permet l'importation d'un ensemble de module.
Chaque spécification d'import \lstcode{<import spec>} peut être soit une simple
importation ou un importation avec un niveau. Le niveau d'importation est soit:
\lstcode{run}, \lstcode{expand} ou \lstcode{(meta <level>)}.  Le niveau méta
donné par \lstcode{<level>} est un entier exacte. Un niveau d'importation 0
correspond à \lstcode{run} et un niveau d'importation de 1 correspond
\lstcode{expand}.

% L'importation d'un module contient les sous formes suivantes:
% \begin{center}
% \begin{mplisting}{0.7}
%   <libref>
%   (library <libref>)
%   (only <import set> <identifier_1> ...)
%   (except <import set> <identifier_1> ...)
%   (prefix <import set> <identifier>)
%   (rename <import set> (<identifier_1> <identifier_2>))
% \end{mplisting}
% \end{center}

% \begin{itemize}
%   \item \lstcode{(rename  (<identifier1> <identifier_2>))}
% \end{itemize}

La syntaxe pour l'importation avec les niveau méta est décrit dans la
spécification R6RS~\cite{Scheme:R6RS}. Le \lstcode{import} R6RS permet un grand
contrôle lors de l'importation des modules au prix d'une sémantique plus complexe.

Les déclarations d'un module R6RS sont dans espace distinct de l'espace global et
des autres modules. Les déclarations d'un module ne peuvent pas être en conflit avec
des déclaration global ou d'autre module. L'élément qui distingue deux module est
son nom avec sa version. Le nom du module correspond à l'espace de nom du module.
C'est ce qui lie les déclarations au module et empêche les conflits de nom entre
les modules.


%Cette syntaxe
%est fortement lié à ce module. Chaque module a son propre
%espace de environnement. dans l'espace de nom du module sert d'espace de nom pour les associations
%du module. Ce modèle introduit le concept d'espace de nom
%qui donne l'appartenance des fonctionnalités à un module. Cela règle le
%problème que module redéfinisse les fonctionnalités d'un autre module.


% Le concept de bibliothèque a été raffiné  dans le R6RS.  Le R6RS rend le
% support de la procédure \texttt{load} optionnel et ajoute une forme spéciale
% \texttt{library} pour définir des bibliothèques et une autre forme spéciale
% \texttt{import} pour gérer la inclure une bibliothèque.  Les noms utilise
% pour nommer une bibliothèque peuvent seulement contenir des symboles et des
% numéros de versions à la fin. Les expression import et export doivent seulement
% apparaître une seul fois dans le définition de la bibliothèques.

% Les bibliothèques ainsi définit, lie chaque définitions à la bibliothèque.  Cela
% permet la réutilisation des mêmes identificateurs dans deux bibliothèque
% différente.  Les conflits de nom sont gérés lors de l'importation des la
% bibliothèques. L'importation d'un module est permit au sein d'une bibliothèque
% comme dans un programme principale. La syntaxe d'un import reste identique dans
% ce deux cas.

% Pour évité ces conflit, il faut que tous les noms utilisés au sein des
% bibliothèques soit distinct, ce qui ajoute une tâche au programmeur.

% What is define-library?
Le standard R7RS\cite{Scheme:R7RS} simplifie la syntaxe des modules
R6RS\cite{Scheme:R6RS}.  L'importation d'un module fait abstraction du niveau
d'importation. Les macros et les procédures sont importés de façon
transparente. La procédure \lstcode{load} est conservée. La forme spéciale pour
définir un module est \lstcode{define-library}. Il n'y a pas d'ordre spécifique
dans les déclarations de la bibliothèque comme en R6RS. Un module R7RS commence par
un nom suivit de plusieurs déclarations.\\
\begin{center}
  \lstset{language={scheme},
          captionpos=b,
          caption={Structure globale d'un module R7RS},
          label={lst:syntax->define-library}}
  \begin{mplisting}{0.5}
(define-library <library name>
  <library declaration>*)
\end{mplisting}
\end{center}

Une déclaration dans un module est soit un \lstcode{import}, un \lstcode{export},
un \lstcode{include}, un \lstcode{include-ci}, un \lstcode{cond-expand} ou un
bloque \lstcode{begin}.
\begin{itemize}
  \item La déclaration \lstcode{import} est équivalent au R6RS sans le concept
    de niveau d'importation.

  \item La déclaration \lstcode{export} est idem au R6RS.

  \item Les déclarations \lstcode{include} et \lstcode{include-ci} permettent
    l'inclusion d'un fichier en tant qu'un bloque de code.  La seconde version
    non sensible à la casse des caractères.

  \item La déclaration \lstcode{cond-expand} est un extension du \texttt{SRFI-0}
    dans le contexte d'une bibliothèque.

\end{itemize}

La forme \lstcode{import} en R7RS permet d'importer un ensemble d'identifiants
qui sont exporté par un module. Chaque ensemble importé spécifie le nom des
identifiants du module et parfois même associe un nom local aux identifiants.
Le \lstcode{import} peut prendre l'une des formes suivante:
\begin{itemize}
  \item \lstcode{<library-name>}
  \item \lstcode{(only <import-set> id1 ...)}
  \item \lstcode{(except <import-set> id1 ...)}
  \item \lstcode{(prefix <import-set> id)}
  \item \lstcode{(rename <import-set> (id1 id2) ...)}
\end{itemize}


--------------------------------------END---------------------------------------\\


% L'implémentation des bibliothèques Scheme est basé sur le standard R7RS qui
% conserve la procédure \texttt{load} que le R6RS enlève et remplace la structure
% des bibliothèques.  Une bibliothèque en R7RS remplace la forme
% \lstcode{library} par \texttt{define-library}. Ces deux formes ont beaucoup de
% similarité, il existe une méthode pour transformer certaines bibliothèques R6RS
% en bibliothèques R7RS. Takashi Kato a publié un article au \emph{Scheme
% Workshop} 2014 qui explique une procédure pour écrire un module R6RS en R7RS
% \cite{SW2014:R6RS/on/R7RS}.  L'extension de fichier utilisé par les définitions
% des bibliothèques est \verb|.sld| qui signifie \emph{Scheme Library
% Declaration}.

\begin{center}
  \begin{figure}[h]
  \begin{tabular}{|l|l|}
    \hline
    \begin{mplisting}{0.5}
;; Library R6RS
(library (math)
  (export fact)
  (import (rnrs base))
  (define (fact n)
    (if (< n 2)
      1
      (* n (fact (- n 1))))))
\end{mplisting} &
    \begin{mplisting}{0.5}
;; Library R7RS
(define-library (math)
  (export fact)
  (import (scheme base))
  (begin
    (define (fact n)
      (if (< n 2)
        1
        (* n (fact (- n 1)))))))
\end{mplisting}\\\hline
  \end{tabular}
    \caption{Comparaison entre la syntaxe des modules R6RS et R7RS}
% \caption{À gauche, il y a un exemple d'une bibliothèque mathématique dans le format R6RS qui implémente
% la fonction factoriel. À droite, une réécriture de la bibliothèque de gauche en R7RS.}
  \label{fig:r6rs_r7rs_math_mdoule}
\end{figure}
\end{center}

La syntaxe \lstinline{import} définit dans le R7RS indique le nom de
de la bibliothèque à collecter en plus des information sur les composante
à importer.
\begin{figure}[ht]
  \begin{mplisting}{0.9}
(import (only (gambit thread) make-thread thread-start! thread-join!))
\end{mplisting}
  \caption{Importation d'un sous-ensemble des fonctionnalité de la bibliothèque}
\end{figure}

% - (import (foo)) ; exportant f1 f2 f3
% ===>
% - (##demand-module foo)
% - (##namespace ("foo") f1 f2 f3)
% - macros
% - (##namespace (""))



%% ---- MOVED to chapter 4 ----

%\section{Chargement des bibliothèques}

%Un système est composé d'un ensemble d'éléments (modules) qui interagissent
%entre eux.  Une bibliothèque fait office de module au sein d'un système simple
%ou complexe.
%%La collection des modules s'effectue au sein d'un

%% TODO: voir chargé
%Le chargement d'une bibliothèque Scheme (ou module) est séparé en plusieurs niveaux.
%% TODO: later
%Les bibliothèques sont soit lu du disque vers la mémoire durant l'exécution
%ou déjà dans la mémoire du processus. Durant la compilation les modules sont
%collecté pour construire un exécutable. Le chargement
%d'une bibliothèque inclut une phase de recherche sur le système de fichier pour valider
%l'existence de la bibliothèque et des fonctionnalités demandés. L'emplacement des
%bibliothèques sur le système de fichier est lié par défaut aux chemin spécifié par
%le \lstinline{##module-search-order} a comme défaut \lstinline{~~lib} et \lstinline{~~userlib}.


%La procédure exacte de chargement des bibliothèques par \verb|import|
%n'est pas spécifier par le standard R7RS. Le standard spécifie seulement la syntaxe
%à utilisé et le de comportement principal qui est
%requis. L'importation d'une bibliothèque doit chargé la bibliothèque
%et rendre c'est fonctionnalité disponible dans le contexte
%l'importation a eu lieu qui peut soit ovenir d'un programme principale
%ou d'une bibliothèque.

%Le chargement d'une bibliothèque peut-être effectuée à l'exécution par
%l'utilisation de \texttt{eval} (par \texttt{load}) pour les fichiers source et
%\texttt{load-objcet-file} pour les bibliothèques compilées. Cette recherche
%peut aussi avoir lieu durant l'édition des lien en utilisant les méta-infos
%contenus dans les \textbf{.c} qui sont chacun compilé par le compilateur C
%en \textbf{.o} et lié par le \textit{linker}.

%\section{Modèle dynamique}
%Dans ce modèle les bibliothèques sont lié au programme durant l'exécution. Cela
%nécessite que les bibliothèques soit organisé sur le système de fichier d'une façon
%distingable. Chaque module doit posséder un nom unique qui permet d'y référer.
%Ce nom unique va être utilisé lors de la collection des dépendances.


%%Les bibliothèques
%%sont soit en code source ou compilé nativement avec l'extension (\textit{.oN})
%%où le N correspond à la version du binaire qui commence à 1.


%La recherche des bibliothèques est effectué dans un ordre spécifique
%indépendant de la spécification.  L'algorithme de recherche les bibliothèques
%prend entré le nom de la bibliothèque et retourne le chemin absolu
%correspondant à sont emplacement dans l'arborescence du système de fichier. Les
%bibliothèques sont situées dans différents répertoires l'origine du programme,
%le répertoire des bibliothèques système (\lstinline{~~lib}) et le
%répertoire de bibliothèque utilisateur (\lstinline{~~userlib}).

%% \begin{itemize}
%%   %% XXX: directory where the executable is located (usefull for devel no need to install the module). collecté
%%   \item \verb|origin/dummy.sld|
%%   \item \verb|origin/dummy/dummy.sld|
%%   \item \verb|~~userlib/dummy.sld|
%%   \item \verb|~~userlib/dummy/dummy.sld|
%%   \item \verb|~~lib/dummy.sld|
%%   \item \verb|~~lib/dummy/dummy.sld|
%% \end{itemize}

%Chaque module possède trois niveau d'initialisation dans le système numéroté de
%0 à 2. Le niveau 0 indique que le module n'a pas été initialisé. Ces les niveau
%des module qui ont juste été collecté par le système. Le niveau 1 indique que
%le descripteur du module à été récupéré. L'étape 2 est utilisé pour indiquer
%les module chargé.

%Soit un système avec les dépendance suivante:
%\begin{figure}[ht]
%  \includegraphics{figures/system-example}
%  \caption{Un exemple d'un système fictif composé de différents modules.
%  Le module principale se nomme utilise l'extension \textbf{.scm}
%  et les bibliothèques porte l'extension \textbf{.sld}}
%\end{figure} % TODO: use yed for that graph


%Le démarrage du module principal Main.scm déclenche la collection des modules X
%et Y, qui récursivement déclenche la collection de W et Z. L'algorithme de
%collection des modules ignore les module qui apparaisse plusieurs fois au sein
%du graphe.

%Une fois la collection de tous ces modules est complété le descripteur de
%module est récupéré par un appels à \verb|dlopen| et \verb|dlsym| dans le cas
%compilé.


%\section{Module hébergé}

%Un module qui est hébergé est un module qui dont son contenu
%se retrouve sur un domain comme \url{github.com}.


%\begin{figure}[ht]
%\begin{lstlisting}
%hostname      = +( domainlabel "." ) toplabel
%domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
%toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
%alphanum      = alpha | digit
%alpha         = [a-zA-Z]
%digit         = [0-9]
%\end{lstlisting}
%  \caption{Grammaire BNF représentant un hostname selon un sous
%  ensemble du RFC-2396.}
%\end{figure}

%La différence avec la spécification du hostname dans le RFC-2396
%est que le hostname ne peut pas finir par un point et doit contenir
%au moins un \verb|domainlabel|. C'est pour permettre de distingué
%un module local et un module hébergé.

%\subsection{Module gambit/git}

%Ce module offre un interface pour utiliser interagir avec les des dépôts git.
%Il permet de cloner un dépôts qui est hébergé sur \url{github.com}. Un clone du
%dépôts est simplement un copie qui contient les informations suffisantes pour
%passer d'une version d'un module à un autre. L'opération qui permet de changer
%de version est \emph{checkout}.


%%-------------------------------------------------------------------------------
%%
%%Modèle "link dynamique" :
%%  recherche des libs au run time, utilisation de eval (par load) et
%%  load-object-file
%%
%%  % gsi main.scm      ou      % gsc main.scm ; gsi main.o1
%%
%%    origin/main.scm    : (import X Y)
%%          /X/X.sld     : (import)
%%
%% ~~userlib/Y/Y.sld     : (import Z)
%%
%%     ~~lib/Z/Z.sld     : (import)
%%          /Z.o1
%%
%%-------------------------------------------------------------------------------
%%
%%Modèle "link statique" :
%%  recherche des libs au link time en utilisant les méta-infos
%%  dans les .c (demand-lib et supply-lib), chaque .c compilé en
%%  un .o séparément et les .o linkés par le compilateur C
%%
%%  % gsc -obj -keep-c X.sld      ;; créer .c et .o
%%  % gsc -obj -keep-c Y.sld      ;; créer .c et .o
%%  % gsc -obj -keep-c Z.sld      ;; créer .c et .o
%%  % gsc -obj -keep-c main.scm   ;; créer .c et .o
%%  % gsc -exe main.c             ;; combine les .o pour créer main.exe
%%
%%    origin/main.scm    : (import X Y)
%%          /main.c      : (demand-lib X Y)
%%          /main.o
%%          /X/X.sld     : (import)
%%            /X.c       : (demand-lib) (supply-lib X)
%%            /X.o
%%
%% ~~userlib/Y/Y.sld     : (import Z)
%%          /Y/Y.c       : (demand-lib Z) (supply-lib Y)
%%          /Y/Y.o
%%
%%     ~~lib/Z/Z.sld     : (import)
%%          /Z/Z.c       : (demand-lib) (supply-lib Z)
%%          /Z/Z.o
%%
%%-------------------------------------------------------------------------------
%%
%%Modèle "whole-program" :
%%  recherche des libs au compile time en utilisant les imports
%%  dans les fichiers sources, les AST de toutes les libs fusionnées
%%  en un seul AST compilé par gsc (donc un seul .c généré et compilé
%%  par le compilateur C pour créer main.exe)
%%
%%  % gsc -exe -whole-program main.scm
%%
%%    origin/main.scm    : (import X Y)
%%          /X/X.sld     : (import)
%%
%% ~~userlib/Y/Y.sld     : (import Z)
%%
%%     ~~lib/Z/Z.sld     : (import)
%%
%%-------------------------------------------------------------------------------
%% correction d’une petite coquille…
%% /Y.c       : (demand-lib Z) (supply-lib Y)
%% /Y.o
%%
%% ~~lib/Z/Z.sld     : (import)
%% /Z.c       : (demand-lib) (supply-lib Z)
%% ...


%% (check-sld "/tmp/scheme/base/base.sld" "/tmp/scheme/base")
%% (check-sld "/tmp/scheme/base.sld" "/tmp/scheme")
%% (check-sld
%%  "/home/frederic/Documents/MasterResearch/gambit9/lib/cocolappin/scheme/base/base.sld"
%%  "/home/frederic/Documents/MasterResearch/gambit9/lib/cocolappin/scheme/base")
%% (check-sld
%%  "/home/frederic/Documents/MasterResearch/gambit9/lib/cocolappin/scheme/base.sld"
%%  "/home/frederic/Documents/MasterResearch/gambit9/lib/cocolappin/scheme")
%% (check-sld
%%  "/home/frederic/Documents/MasterResearch/g9/lib/scheme/base/base.sld"
%%  "/home/frederic/Documents/MasterResearch/g9/lib/scheme/base")
%% object-file-path: /home/frederic/Documents/MasterResearch/g9/lib/scheme/base/.gambit_409003@C/base.o1
%% ("/home/frederic/Documents/MasterResearch/g9/lib/scheme/base/base.sld"
%%  .
%%  #<input-port #2 "/home/frederic/Documents/MasterResearch/g9/lib/scheme/base/base.sld">)
